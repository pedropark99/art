<!--
Stock prices are an example of chaos that exists in our economic system.
For example, if tomorrow, Microsoft suffers a huge lost of investments (because
of a wrong strategy, or some internal scandal, etc.), the stock prices
of Apple will most likely go up. Apple did not had do to
a thing! Its concurrent made a mistake, as a result, the price of its
stock raised "automatically", as a side-effect.

Also, huge and billionaire companies such as Apple have some degree of
control over their stock price. In other words, these companies can
inject huge amounts of money into the market, or, influence government decisions
to slightly influence the price of their stocks.
So when these big companies influence the market, we introduce
a new effect on the table.

Sometimes we can predict some of these effects,
specially if we have good sources of information inside the market.
But there are so many effects (both in quantity and in quality), that becomes impossible
to comprehend all of these effects at once, hence the "chaos feeling" that you feel
when you work with the stock market.

This is frustrating for humans. We want to comprehend everything we are seeing!
We want to know why, when, who and how everything happens.
But at the same time, we as humans have limited resources: a limit
amount of attention that we can spend, and limited brain processing power
that we can spend when learning/understanding about something.

That is why some degree of order, or symmetry, or logic in a image is very
pleasant to the eyes. Because is easy to understand a symmetric object.
We can easily understand what we are seeing in the image.

So when you are building your generative art, you want some degree of
chaos and randomness. But you also want to balance this chaos with some
degree of order. Hence the current chapter title (producing chaos in an ordered manner).
-->


# Producing chaos in an ordered manner

In this chapter, we will study more about how to produce chaos
with randomness. We will learn about the different styles of
randomness that are available in R, and we will also learn
about producing randomness in one and two dimensional spaces.

Generative art is mostly a synergy between chaos and order.
A big part of it comes from combining random patterns
we find in nature with the order and logic of math.
In other words, we use geometry and a lot of math to draw and mold shapes
in the screen, and we combine that with randomness to
achieve random patterns that are interesting to look
at.

However, chaos is a hard topic in general for us, programmers. Because
our job is the complete opposite of chaos. We work with
logic, precision, and computers. Chaos and randomness is not
a part of our essence.

Furthermore, computers are, essentially, precision machines.
As a result, it seems very wrong and unlikely to use them
to produce chaos. But you can achieve that, if you want to,
by asking the computer to produce random values, and using
these random values as factors to produce the chaos you want.

## The different styles of randomness {#sec-random-styles}

We have different generators of random values available in R.
Each generator produces random values following a specific
rule or target. And as a consequence of that, the
randomness that each generator produces will be slightly different
from the others.

In base R, there at least three generators that you must known:

- `runif()` produces random values that follow a uniform distribution;
- `rnorm()` produces random values that follow a normal distribution;
- `sample()` produces a random sample from a set of values;

The functions `runif()` and `rnorm()` can be used to generate random numbers, and
the function `sample()` can be used when you are trying to select a random sample
from a known set of values. To some extent, you can say that `sample()` is used
whenever you want to randomly select a value (or select a random sample of values)
from a known set of values.

There are other generators available in R that might be very useful,
specially trough the `ambient` R package[^ambient-pkg],
which is a R interface to the `FastNoise` C++ library.

This `ambient` package offers two other generators that will be discussed here,
which are:

- `ambient::noise_perlin()`: produces random values using the Perlin Noise algorithm.
- `ambient::noise_simplex()`: produces random values using the Simplex Noise algorithm.

[^ambient-pkg]: <https://ambient.data-imaginist.com/index.html>.


## About random seeds and random number generation

Computers can not generate "true random numbers". Instead, they use an
"initial state" as the basis for generating the random values.
Having that in mind, we can say that computers generate
"pseudo-random numbers".

For the most part, this "initial state", from which the random numbers
are generated, is represented as an integer. This integer is called
as the "seed for the random number generator", or simply, a "random seed".
So, to generate random numbers in R, or in Python, or in JavaScript, or in any other language,
we use an integer as the "seed" to represent the initial state for the random
number generator.

In the example below, we can see that every time I run the two calls to `runif()`,
I get a different answer as result, or a different set of random values:

```{r}
runif(3)
runif(3)
```

If I do not set any specific "seed" to be used, R will
automatically, and "randomly", choose a seed for me.
And because of that, the results in the example above are different between
each call to `runif()`. Because the seeds used
in each call are different.

By using the same "seed" as the initial state, we can produce
the exact same set of random numbers. This means that,
if we want to have reproducibility in random numbers generators,
to reproduce the same set of random values, we need to use
the same random seed that was used before.

You can set the integer to be used as the random seed, by using the
`set.seed()` function.
In the example below, you can see that, by setting the random seed
to 40, I get the exact same set of random values as a result
in each call to `runif()`.

```{r}
set.seed(40)
runif(3)
set.seed(40)
runif(3)
```

This is really important, because randomness is an important aspect
of generative art, and, if you do not set the random seed to be used
when generating the randomness, then, you will never be able to easily
reproduce this same set of random values. And by not reproducing the same set
of random values, you will likely not be able to reproduce the same
output in your generative art.

You should always set the random seed you are using in your process.
By not doing this, you are facing the risk of producing a very cool
output in your code by completely accident, and not being able
to save this output in time, or reproducing it later in the day,
or improving it by adding more adjusts in configuration, colors, brightness, and positions.



## Generating one dimensional randomness

We begin our discussion by generating random values in one dimension.
Since, these generators from the `ambient` R package are generators for 2 to 3 dimensions.
Because of that, we will talk about them solely at @sec-two-dimensions-random.

## Generating two dimensional randomness {#sec-two-dimensions-random}

### The true randomness of `runif()`

```{r}
library(ggplot2)
n <- 100
set.seed(40)
random <- matrix(runif(n ^ 2), n, n)

d <- data.frame(
  col_id = rep(seq_len(n), each = n),
  row_id = rep(seq_len(n), times = n),
  value = random |> as.vector()
)


ggplot(d) +
  geom_point(
    aes(x = col_id, y = row_id, color = value),
    size = 3
  ) +
  theme_void()
```

When we use `rnorm()`, it still produces a pretty random result. However,
we can see that the colors are more flat, they seem less random compared
to `runif()`. What is happening is that `rnorm()` outputs random values
based on a probabilistic distribution, or more specifically, based on
a mean value.

The end result of this, is that `rnorm()` tend to output values that
are closer to the mean of the probabilistic distribution. In the case
below, the mean value of the distribution is zero. So, the colors in
the image below seen more flat, because the majority of the values
sorted by `rnorm()` are values that are very close to zero.

Hence, what you see in the image below is still a collection of many random values.
But a big chunk of these random values are values that are very close to zero.
That is why most of the points in this image are in the middle of
the black and blue gradient scale.

```{r}
set.seed(40)
random <- matrix(rnorm(n ^ 2), n, n)

d <- data.frame(
  col_id = rep(seq_len(n), each = n),
  row_id = rep(seq_len(n), times = n),
  value = random |> as.vector()
)


ggplot(d) +
  geom_point(
    aes(x = col_id, y = row_id, color = value),
    size = 3
  ) +
  theme_void()
```



```{r}
library(ambient)
random <- noise_perlin(c(n, n))

d <- data.frame(
  col_id = rep(seq_len(n), each = n),
  row_id = rep(seq_len(n), times = n),
  value = random |> as.vector()
)


ggplot(d) +
  geom_point(
    aes(x = col_id, y = row_id, color = value),
    size = 3
  ) +
  theme_void()
```




