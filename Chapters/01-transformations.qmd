---
editor: 
  markdown: 
    wrap: 72
---

# Introducing graphics transformations

When we are displaying some object (or shape) in an image, we might want
to transform this object (or shape) in some way. For example, we might
need to move this object to a different location in the image, or we
might need to scale this object to a different size, or maybe, to rotate
it into a different angle.

In computer graphics, this is called as a **transformation**. We apply a
*transformation* to the object we have, and this object gets moved in
some way in the visual space of our image. There are three basic
transformations that are essential to the world of computer graphics,
which are:

-   Scaling.
-   Translation.
-   Rotation.

Each of these three basic transformations uses simple math operations
over the coordinates of the vertices that compose your object to achieve
a specific visual effect/transformation.

## Translation

Lets begin with the easiest and simplest of all transformations, which
is translation. A translation is used to move your object to a different
position in the Cartesian field.

@fig-translation presents this transformation visually. The light blue
rectangle represents the original position of the rectangle in the
Cartesian field. While the strong blue rectangle represents the new
position where the original rectangle was moved to after we applied the
translation.

![An example of translating an object in a Cartesian
field](./../Figures/01-translation.svg){#fig-translation}

But how translation works? In summary, to translate an object, all you
have to do is to add a "x offset" and a "y offset" to all vertices of
your object. The "x offset" represents how much you want to move the
object horizontally, while the "y offset" represents how much to move
the object vertically.

The direction of the movement is determined by the signal of the offset
(i.e. if it is a positive or a negative number). For example, if you
want to move your object to the right, then, you add a positive x offset
to each x position. But if you want to move your object to the left
instead, then, you add a negative x offset. The same logic applies to
vertical movements.

For example, a triangle have three vertices. If we want to translate
this triangle three points to the left, and two points up, then, we need
to add the number 3 to the x position, and the number 2 to the y
position of the three vertices of this triangle.

The following code demonstrates this idea. We have a first triangle
(object `triangle`), represented by the vertices $(-1,0), (1,0), (0,2)$.
Then, we create a new triangle (object `translated_triangle`) from the
first one, by translating it with a x and y offsets to each x and y
positions, respectively.

```{r}
library(ggplot2)
triangle <- data.frame(
  x = c(-1, 1, 0),
  y = c(0, 0, 2)
)

x_offset <- 3
y_offset <- 2
translated_triangle <- data.frame(
  x = triangle$x + x_offset,
  y = triangle$y + y_offset
)

canvas <- ggplot() +
  theme_minimal() +
  lims(y = c(-1, 5), x = c(-1, 5)) +
  geom_vline(aes(xintercept = 0), color = "#222222") +
  geom_hline(aes(yintercept = 0), color = "#222222")

canvas +
  geom_polygon(
    aes(x = x, y = y, fill = "Before translation"),
    data= triangle
  ) +
  geom_polygon(
    aes(x = x, y = y, fill = "After translation"),
    data= translated_triangle
  ) +
  scale_fill_manual(values = c("#226ce3", "#a6c8ff"))
```

So, if you need to translate any object in your image, you always need
to do the same thing, which is to add x and y offsets to the vertices of
your object.

However, the way you do this addition can vary depending on the specific
geom you are using in your plot. Because different geoms in `ggplot2`
can treat the vertices of your object very differently. In other words,
each geom can use very different strategies to actually build the object
your describing with your data, and because of that, you might need to
change the way you add these offsets to your data, to actually make the
translation work properly.

For example, you can draw rectangles by using `geom_rect()` or
`geom_tile()`. But these geoms are completely different in the way they
draw the actual rectangle. `geom_rect()` draws a rectangle by using the
coordinates of the four corners (or vertices) of the rectangle. In
contrast, `geom_tile()` draw a rectangle by using a single coordinate
(which is the center of the rectangle), plus the width and height of the
rectangle.

If you needed to translate a rectangle drawn by the `geom_rect()` geom,
then, you do the same logic as the previous code example. But, in the
other hand, if your rectangle is drawn by the `geom_tile()` geom
instead, then, all you need to do is to translate a single coordinate,
which is the center point of the rectangle.

```{r}
r <- data.frame(
  center_x = 0.5,
  center_y = 0.25,
  width = 1,
  height = 0.5
)

x_offset <- 3
y_offset <- 2
translated_r <- data.frame(
  center_x = r$center_x + 3,
  center_y = r$center_y + 2,
  width = 1,
  height = 0.5
)

canvas +
  geom_tile(
    aes(x = center_x, y = center_x,
        height = height, width = width,
        fill = "Before translation"),
    data = r
  ) +
  geom_tile(
    aes(x = center_x, y = center_x,
        height = height, width = width,
        fill = "After translation"),
    data = translated_r
  ) +
  scale_fill_manual(values = c("#226ce3", "#a6c8ff"))
```

## Scaling

Scaling is used to scale your object into a different size (i.e. to
raise/shrink the size of your object). @fig-scaling presents this
process visually. We begin with the light blue and smaller triangle, and
then, we scale this triangle into a bigger size, getting the strong blue
triangle as a result.

![Scaling a triangle into a bigger
size](./../Figures/01-scaling.svg){#fig-scaling}

To scale an object, we perform essentially the same thing that we did in
translation, which was a simple math operation over the coordinates of
the vertices that compose our object. But instead of adding offsets to
the coordinates, we multiply each coordinate by a fixed amount/factor.

As an example, lets create a new triangle with the coordinates
$(0,0), (1,0), (0,2)$. We can get a triangle that is twice bigger by
multiplying each coordinate by a factor of two.

```{r}
triangle <- data.frame(
  x = c(0, 1, 0),
  y = c(0, 0, 2)
)
twice_triangle <- data.frame(
  x = triangle$x * 2,
  y = triangle$y * 2
)

canvas +
  geom_polygon(
    aes(x = x, y = y, fill = "After scaling"),
    data= twice_triangle
  ) +
  geom_polygon(
    aes(x = x, y = y, fill = "Before scaling"),
    data= triangle
  ) +
  scale_fill_manual(values = c("#226ce3", "#a6c8ff"))
```

If you want to scale your object, but at the same time, keep the same
center position as the original object, then, we need to perform two
transformations at once: scaling and translation. We first scale the
object to the size we want, and then, we translate this object to the
same center position as the original object. Take this case as an
example:

```{r}
triangle <- data.frame(
  x = c(0.25, 1.5, 0.5),
  y = c(0.5, 0.5, 2)
)
twice_triangle <- data.frame(
  x = (triangle$x * 2) - (max(triangle$x) / 2),
  y = (triangle$y * 2) - (max(triangle$y) / 2)
)

canvas +
  geom_polygon(
    aes(x = x, y = y, fill = "After scaling"),
    data= twice_triangle
  ) +
  geom_polygon(
    aes(x = x, y = y, fill = "Before scaling"),
    data= triangle
  ) +
  scale_fill_manual(values = c("#226ce3", "#a6c8ff"))
```

So all you need to do is to multiply each coordinate by the factor you
want to scale the object. If you want a bigger object, then, the factor
must be a number greater than 1. But if you want a smaller object
instead, then, the factor must be a number between 0 and 1. For example,
if you want an object that is half the original size, you should use the
factor is 0.5.

## Rotation

Rotation is a transformation used to rotate your object to a different
angle. @fig-rotation presents this transformation visually. We start
with the light blue rectangle, which is parallel to the x axis, and
then, we rotate this rectangle into a new angle, getting the strong blue
rectangle as the result.

![Rotating a rectangle into a different
angle](./../Figures/01-rotation.svg){#fig-rotation}

Rotating an object is a little more complicated than the other
transformations. Only because it involves some magic calculations with a
little of trigonometry.

Given a coordinate with $x$ and $y$ positions in a Cartesian plane, and
a angle $A$ in radians to rotate this initial coordinate, the new $x'$
and $y'$ positions of this coordinate after the rotation can be
calculated using the formulas below. $\cos()$ and $\sin()$ in these
formulas are the cosine and sine trigonometric functions.

$$
x' = x \times \cos(A) + y \times - \sin(A)
$$ {#eq-rotation1}

$$
y' = x \times \sin(A) + y \times \cos(A)
$$ {#eq-rotation2}

### Remember to convert your angles in degrees to radians

This seems complicated, but, it is actually not. I mean really, you just
have to follow these formulas above and you will be happy. But remember
one important detail about these formulas: the trigonometric functions
`cos()` and `sin()` take as input **angles that are in radians**.

This is important, because we usually think or talk about angles using
the degrees measure, which goes from -360 to 360 (e.g. 90 degrees, 180
degrees, etc.). So you must convert your angle in degrees to radians,
before you pass it to `cos()` and `sin()` functions.

You can do this by using the function `deg2rad()` that we introduced at Chapter 1.
To make life easier, the function definition is repeated below:

```{r}
# A function to convert degrees to radians
deg2rad <- function(deg){
  return(deg * pi / 180)
}
```

### A first example of rotation

As a first example, lets take a triangle with coordinates
$(0,0), (1,0), (0,2)$. Lets consider we wanted to perform two different
rotations over this triangle. The first, we rotate it to 30 degrees
clockwise, and in the second, 90 degrees clockwise.

```{r}
triangle <- data.frame(
  x = c(0, 1, 0),
  y = c(0, 0, 2)
)

angle <- deg2rad(-30)
first_rotated_triangle <- data.frame(
  x = (triangle$x * cos(angle)) + (triangle$y * -1 * sin(angle)),
  y = (triangle$x * sin(angle)) + (triangle$y * cos(angle))
)

angle <- deg2rad(-90)
second_rotated_triangle <- data.frame(
  x = (triangle$x * cos(angle)) + (triangle$y * -1 * sin(angle)),
  y = (triangle$x * sin(angle)) + (triangle$y * cos(angle))
)

canvas +
  geom_polygon(
    aes(x = x, y = y, fill = "After second rotation"),
    data = second_rotated_triangle
  ) +
  geom_polygon(
    aes(x = x, y = y, fill = "After first rotation"),
    data = first_rotated_triangle
  ) +
  geom_polygon(
    aes(x = x, y = y, fill = "Before rotation"),
    data = triangle
  ) +
  scale_fill_manual(values = c("#226ce3", "#0c3a85", "#a6c8ff"))
```

Another **very important aspect** about this operation, is that the
above formulas (@eq-rotation1 and @eq-rotation2) calculate the new
coordinates of the object considering the origin point of the Cartesian
plane, i.e. coordinate $(0, 0)$ as the "center point of the rotation".

In other words, instead of rotating around the center point of the
object itself, or, rotating around the leftmost point of the vertices of
the object, or around whatever other point you imagine, the object is
rotated around the origin point of the Cartesian plane.

You can imagine this rotation as if the object followed the
circumference of a circle that is centered in the origin point. The
radius of the circle that is formed by this circumference is the actual
distance that the object is from the origin point.

You can see this fact more clearly by increasing the distance of your
object from the origin point. In the example below, the same triangle
and rotation angles as the previous example are used. But this time, the
original triangle is further apart from the origin point (code is
omitted for brevity reasons). To help you visualize, I have also
drawn the circle that is centered at the origin point. You can see that the
rotated triangles follows the circumference of that circle.

```{r}
#| echo: false
triangle <- data.frame(
  x = c(0, 1, 0),
  y = c(3, 3, 5)
)

angle <- deg2rad(-30)
first_rotated_triangle <- data.frame(
  x = (triangle$x * cos(angle)) + (triangle$y * -1 * sin(angle)),
  y = (triangle$x * sin(angle)) + (triangle$y * cos(angle))
)

angle <- deg2rad(-90)
second_rotated_triangle <- data.frame(
  x = (triangle$x * cos(angle)) + (triangle$y * -1 * sin(angle)),
  y = (triangle$x * sin(angle)) + (triangle$y * cos(angle))
)

circle <- data.frame(
  x = 3 * cos(deg2rad(1:361 - 1)),
  y = 3 * sin(deg2rad(1:361 - 1))
)


canvas +
  geom_polygon(
    aes(x = x, y = y, fill = "After second rotation"),
    data = second_rotated_triangle
  ) +
  geom_polygon(
    aes(x = x, y = y, fill = "After first rotation"),
    data = first_rotated_triangle
  ) +
  geom_polygon(
    aes(x = x, y = y, fill = "Before rotation"),
    data = triangle
  ) +
  geom_path(
    aes(x, y, color = "Circumference of the circle\ncentered at origin"),
    data = circle
  ) +
  scale_fill_manual(values = c("#226ce3", "#0c3a85", "#a6c8ff"))
```

### How to rotate lines

Therefore, you use @eq-rotation1 and @eq-rotation2 to calculate the new
coordinates of a **polygon** that was rotated by a certain angle. But
rotating lines is kind of a special case, because it is a bit trickier
to rotate lines than most polygons.

You can still use @eq-rotation1 and @eq-rotation2
to calculate the new coordinates of a line after you rotated it by a
certain angle. However, I personally find these equations less intuitive
for this specific case.

This means that there is another pair of equations that I personally
prefer to use when I want to rotate a line. Actually, you already saw
this pair of equations here in this book, which are
@eq-rotation3 and @eq-rotation4 that were presented in Chapter 1.


Lets begin our example with a line with coordinates $(1.5, 0.6)$ and $(3.7, 2.7)$.
This line is exposed in the plot below:

```{r}
line <- data.frame(
  x = c(1.5, 3.7),
  y = c(0.6, 2.7)
)

canvas +
  geom_line(aes(x,y), data = line)
```

Lets suppose you wanted to rotate this line 75 degrees counter-clockwise.
How you do it? In this context, the variable $r$ that is present at
@eq-rotation3 and @eq-rotation4 becomes the length of the line.
So, first, we need to calculate the length of the line.

Given that $l$ is the line length that we want to calculate, and that
$x_1$ and $y_1$ are the x and y positions of any of the endpoints
of the line, and that $x_2$ and $y_2$ are the x and y positions
of the other endpoint of the line, you can calculate the line
length by following the formula below. This formula is also known
as the "distance formula".

$$
l = \sqrt{[(x_2 - x_1)^2 + (y_2 - y_1)^2]}
$${#eq-linelength}

Is important to emphasize, that you can choose whatever endpoint
you want for $x_1$ and $y_1$. It can be the leftmost point of the line,
or the rightmost. Once you choose the endpoint for $x_1$ and $y_1$,
the endpoint for $x_2$ and $y_2$ automatically becomes the other
endpoint.

In our example, lets use $(1.5, 0.6)$ as our endpoint 1, and $(3.7, 2.7)$
as our endpoint 2. With that, the line length is:

$$
l = \sqrt{(3.7 - 1.5)^2 + (2.7 - 0.6)^2}=3.041381
$$

We can obviously encapsulate @eq-linelength into a nice R function that we can reuse
whenever we want. If we do that, we get a function similar to `line_length()` below:

```{r}
# Function to calculate the length of a line
line_length <- function(x1, y1, x2, y2){
  s1 <- (x2 - x1)^2
  s2 <- (y2 - y1)^2
  return(sqrt(s1 + s2))
}

l <- line_length(1.5, 0.6, 3.7, 2.7)
l
```


Now that we have the line length, we can rotate the line in 75 degrees clockwise.





