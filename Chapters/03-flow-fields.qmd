
# Introducing Flow Fields {#sec-flow-fields}

Flow fields are one of the most iconic and powerful techniques used
in generative art. The essential idea behind a flow field
is to create a grid of angles. When a object moves through
this grid, it follows the direction of the angle that
is stored in the current position that this object is
on the grid [@hobbsflow].

```{r}
#| include: false
library(tidyverse)
```

```{r}
#| include: false
knitr::opts_chunk$set(dev = "ragg_png")
```

In other words, by having a grid of angles as the basis,
we basically pick a starting point somewhere
in this grid, then, we start walking through this grid, by taking
small steps in the direction of the angle that we are currently
seeing. We walk as much as we much as we want/need to.


You could also understand flow fields as a very powerful way
of creating interesting curves and paths.
If your art involves these types of elements, a flow
field might be the perfect technique for you.


## Building a grid of angles

Let's start with "how to create a grid of angles?". Since we are talking
about a 2D grid, with x and y coordinates, we want to store
this grid either as a 2D matrix, or, as a `tibble` with
x and y columns. To do that, you
could use the exact same techniques as we used at
@sec-two-dimensions-random, to build a 2D matrix or a `tibble`
to store two dimensional random values.

In essence, if you prefer to build the 2D matrix, you could simply pass the vector
with all the angles values in the grid to the `matrix()`,
and specifying the number of columns and rows that you want to use.

In the other hand, if you prefer the `tibble` instead, we
used the `rep()` function in conjunction with `seq_len()` to
build the x and y coordinates columns in the `tibble`.
The function `build_grid_df()` below summarizes this technique:

```{r}
library(tibble)
build_grid_df <- function(angles, n) {
  tibble(
    x = rep(seq_len(n), each = n),
    y = rep(seq_len(n), times = n),
    value = angles |> as.vector()
  )
}
```


### Building a fixed angle grid

Let's start by building a grid with a fixed angle.
This means that all coordinates in the grid will
have the exact same angle value. So the angle is
"fixed", or "constant" across the grid.

To build such a grid, simply use a constant value
across your matrix or `tibble`. In the example
below, we are creating a 50x50 grid filled
with the angle $\pi/4$.

```{r}
n <- 50
fixed_angle <- pi / 4
grid <- build_grid_df(fixed_angle, n)
grid
```

But how can we can visualize this grid of angles? Well...
we can draw $50^2$ small lines with this same particular angle,
and then, we spread all of these lines
across the grid, using a translation operation
as we presented at @sec-translation.

So, all we have to do, is to draw $50^2$ lines that are identical
(same length, same angle), and then, we apply a translation
to move each individual line to a particular point in the grid.
Like that:

```{r}
library(tidyverse)

visualize_grid <- function(grid, n){
  # Calculate the n^2 lines
  grid <- grid %>% 
    mutate(
      line_id = seq_len(nrow(grid)),
      xend = cos(value),
      yend = sin(value),
    )
  
  # Spread the lines across the grid
  grid <- grid %>% 
    mutate(
      xend = xend + x,
      yend = yend + y
    )
  
  # Plot these lines
  u <- "inches"
  a <- arrow(length = unit(0.025, u))
  ggplot(grid) +
    geom_segment(
      aes(
        x = x, y = y,
        xend = xend,yend = yend,
        group = line_id
      ),
      arrow = a
    ) +
    coord_cartesian(
      xlim = c(0,n), ylim = c(0,n)
    ) +
    theme_void()
}


visualize_grid(grid, n)
```

You can see in the output above, that all lines are in the same angle.
Because the angle value is constant across the grid.
But a flow field with constant angle values is kind of useless.
So let's level up this game by introducing some randomness.




### Building a random angle grid {#sec-grid-random-angle}

Now, we can add a little bit of randomness to this field,
by using random angle values. First, we generate $50^2$
random values with `runif()`.

However, we need to scale these random values. By default,
`runif()` generates random values that are between 0 and 1.
You can use these values as percentages
(from 0% to 100%) to transport them into a different
scale.

The radians scale goes from $-2\pi$ to $2\pi$, when both clockwise, and counter-clockwise
movements are considered. But for this example, let's
consider solely counter-clockwise movements, which
limits the scale to positive values (from zero to $2\pi$).
So we can multiply the random values produced by `runif()` with
$2\pi$, to transport these random values into the radians scale.

After that, we spread these random angle values into a grid
with the `build_grid_df()` function we created before:

```{r}
set.seed(50)
angles <- runif(n ^ 2) * 2 * pi
grid <- build_grid_df(angles, n)
```

Now that we have the grid of angles, all we have to do is to visualize it,
with the `visualize_grid()` function that we created in the previous section.
And yeah... this field is a mess, because we now have $50^2$ lines that are
in completely random angles:

```{r}
visualize_grid(grid, n)
```

In other words, this field is simply too much random! We do need to use random
values to create an actual flow field.
But these random values need to have some minimal level of resemblance with each other.
That is why, `runif()` is not the best tool for generating a flow field.

But despite this being a very messy field, you may find a new utility for it.
Everything depends of your creativity! For example, this field as is, might be 
an interesting candidate to be a soft pattern in the background of your art.
In other words, this flow field might not be the main character in your art,
but he might be an element to support the rest of your idea.

```{r}
#| eval: false
#| include: false
teste <- function(grid, n){
  # Calculate the n^2 lines
  grid <- grid %>% 
    mutate(
      line_id = seq_len(nrow(grid)),
      x_line = map(value, \(x) c(0, cos(x))),
      y_line = map(value, \(y) c(0, sin(y))),
    ) %>% 
    unnest(c(x_line, y_line))
  
  # Spread the lines across the grid
  grid <- grid %>% 
    mutate(
      x = x + x_line,
      y = y + y_line
    )
  
  # Plot these lines
  ggplot(grid) +
    geom_path(aes(x, y, group = line_id), color = "#5f6b5f") +
    coord_cartesian(
      xlim = c(0,n), ylim = c(0,n)
    ) +
    theme_void() +
    theme(
      plot.background = element_rect(fill = "#263F30")
    )
}

teste(grid, n)
```




## Building an actual flow field with Perlin Noise

At @sec-grid-random-angle, we produced a field that was just too much random.
We could hardly call that a "flow field", because there was nothing fluid about it.
The lines across the grid had no connection with each other, like
a machine gun that was desperately shooting to all directions at
the same time.

So now, let's produce an actual flow field. A field of angles that actually makes sense.
And for that, we are going to use the Perlin Noise algorithm (that was presented at @sec-perlin-noise)
in our favor.

First thing we need to do, is to generate the grid of random values. With Perlin Noise,
that is extremely easy to make, because we can easily get a 2D matrix
of random values with the `noise_perlin()` function from the
`ambient` R package, as we described at @sec-perlin-noise.

But this time, we need, once again, to scale these random values produced by Perlin Noise,
so that they represent actual angle values, using the radians scale. To that,
we simply multiply these values by $2\pi$, in the same way as we did at @sec-grid-random-angle.

```{r}
library(ambient)

set.seed(50)
angles <- noise_perlin(c(n, n)) * 2 * pi
grid <- build_grid_df(angles, n)
grid
```


After that, we now have a grid of angles that represents a functional flow field.
We can visualize this field in the same way as we did before:

```{r}
visualize_grid(grid, n)
```


That looks much more natural compared to the previous grids! It also feels much more fluid.
Like winds flowing and doing smooth curves around this grid.

You could also use the Simplex Noise algorithm to generate the random values,
instead of the classic Perlin Noise. However, as we described at @sec-perlin-noise,
the Simplex Noise algorithmn produces "stronger" results, with random values
that vary more rapidly across the grid. As a result, a flow field created
from Simplex Noise is less smooth compared to a flow field created
from classic Perlin Noise. You can see this fact in the example below:

```{r}
set.seed(50)
angles <- noise_simplex(c(n, n)) * 2 * pi
grid <- build_grid_df(angles, n)
visualize_grid(grid, n)
```


## Drawing curves around the grid

Now that we have a functional flow field, we want to use it
to actually draw things in the screen, specially curves.

To do that, we need to walk across the grid.
We choose a point in the grid as our starting point, and then,
we start to walk in the grid by following the direction of
the angles we encounter in the grid. As we walk trough the grid,
we collect the x and y coordinates of our position.
When we finish walking, we can
draw the line, or the curve by "connecting
the dots", i.e. connecting the x and y coordinates that we passed through.

So, in essence, the steps for drawing a curve in a flow field are:

1. Choose a starting point in the grid.
1. Look at the angle that is stored in the position of the grid that you are currently in.
1. Take a step in the direction of that angle.
1. Recalculate your current position in the grid.
1. Comeback to step 2.

You can see in the bullet points above that, we begin a loop at step 5.
So we are repeatedly taking a step in the direction of an angle, recalculating
our current position in the grid, and taking another step in the direction of an angle,
and, as long as we stay inside the boundaries of the grid, we
can repeat this pattern as much as we want to.

As you walking trough the grid, the angle that you currently using might lead you
to walk off the boundaries of the grid. In that you case, you should stop walking,
before you go off the grid. Because if you pass trough the boundaries of the grid,
then, the lookup process we perform to take an angle in the grid, will fail.


We have the first dot, which is the starting
point. Then we look at 

```{r}
#| eval: false
# Set some variables
n_steps <- 15
step_length <- 0.1
grid_width <- 50
# Pre allocate space for the x and y
# coordinates of the curve we are drawing
x_coords <- vector("double", length = n_steps)
y_coords <- vector("double", length = n_steps)

for (i in seq_len(n_steps)) {
  column_index <- as.integer(x_pos)
  row_index <- as.integer(y_pos)
    
  if (column_index <= 0
      || row_index <= 0
      || column_index >= grid_width
      || row_index >= grid_height) {
    break
  }
  grid_angle <- noise_as_angle[row_index, column_index]
  x_step <- step_length * cos(grid_angle)
  y_step <- step_length * sin(grid_angle)
  x_pos <- x_pos + x_step
  y_pos <- y_pos + y_step
    
  line_xs[i] <- x_pos
  line_ys[i] <- y_pos
}
```









