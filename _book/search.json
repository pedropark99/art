[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Practical Generative Art with R and ggplot2: drawing with data",
    "section": "",
    "text": "Welcome\nWelcome! This is the initial page for the “Open Access” HTML version of the book “Practical Generative Art with R and ggplot2: drawing with data”, written by Pedro Duarte Faria.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#about-the-author",
    "href": "index.html#about-the-author",
    "title": "Practical Generative Art with R and ggplot2: drawing with data",
    "section": "About the author",
    "text": "About the author\nPedro Duarte Faria have a bachelor degree in Economics from Federal University of Ouro Preto - Brazil. Currently, he is a Data Engineer at Blip1, and an Associate Developer for Apache Spark 3.0 certified by Databricks.\nThe author have more than 3 years of experience in the data analysis market. He developed data pipelines, reports and analysis for research institutions and some of the largest companies in the brazilian financial sector, such as the BMG Bank, Sodexo and Pan Bank, besides dealing with databases that go beyond the billion rows.\nFurthermore, Pedro is specialized on the R programming language, and have given several lectures and courses about it, inside graduate centers (such as PPEA-UFOP2), in addition to federal and state organizations (such as FJP-MG3). As researcher, he have experience in the field of Science, Technology and Innovation Economics.\nPersonal Website: https://pedro-faria.netlify.app/\nTwitter: @PedroPark9\nMastodon: @pedropark99@fosstodon.org",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#books-metadata",
    "href": "index.html#books-metadata",
    "title": "Practical Generative Art with R and ggplot2: drawing with data",
    "section": "Book’s metadata",
    "text": "Book’s metadata\n\nLicense\nCopyright © 2024 Pedro Duarte Faria. This book is licensed by the CC-BY 4.0 Creative Commons Attribution 4.0 International Public License4.\n\n\n\nCorresponding author and maintainer\nPedro Duarte Faria\nContact: pedropark99@gmail.com\nPersonal website: https://pedro-faria.netlify.app/",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Practical Generative Art with R and ggplot2: drawing with data",
    "section": "",
    "text": "https://www.blip.ai/en/↩︎\nhttps://ppea.ufop.br/↩︎\nhttp://fjp.mg.gov.br/↩︎\nhttps://creativecommons.org/licenses/by/4.0/↩︎",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "Chapters/01-angles.html",
    "href": "Chapters/01-angles.html",
    "title": "1  Coordinates, Angles and Objects",
    "section": "",
    "text": "1.1 Coordinate systems\nThe coordinate system is the system that determines how an object will be positioned in the image given a x and y positions. In other words, this system determines how the x and y positions are combined to position your object in the image.\nIn ggplot2 there are essentially 3 different coordinate systems, which are:\nFigure 1.1: The three coordinate systems available in ggplot2\nBy changing the coordinate system of your image, you change the way the objects are drawn and positioned in your image space (Wickham 2016). The Polar coordinate system is a circular coordinate system. Meaning that its coordinates form a circumference around a center point, and as a consequence, if you draw objects in this coordinate system, these objects tend to assume a round or circular shape.\nBy default, ggplot2 always use the Cartesian coordinate system, which is created from the coord_cartesian() function. This is definitely the most familiar, and common type of coordinate system that see all the time in real life.\nThe Cartesian coordinate system is based on a two-dimensional coordinate plane, that is formed by the intersection of two perpendicular lines. The horizontal line is known as the “x axis”, and the vertical line is known as the “y axis”. We usually identify a specific point/position in a Cartesian plane by giving the coordinate in the plane where this point/position is located.\nA coordinate in the cartesian plane is a pair of values. The first value is the position in the “x axis”, and the second value is the position in the “y axis”. As an example, the coordinate \\((2, 8)\\) represents the point located at \\(x = 2\\) and \\(y = 8\\) in the plane. You could also interpret this coordinate as: it is the point located at two steps to the right, plus eight steps up.\nIs worth noting that ggplot2 is a data visualization framework capable of producing 2D graphics only. So even though the Cartesian system supports 3D graphics by introducing a third axis (z), only the x and y axis are used in the Cartesian plane of ggplot2.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Coordinates, Angles and Objects</span>"
    ]
  },
  {
    "objectID": "Chapters/01-transformations.html",
    "href": "Chapters/01-transformations.html",
    "title": "2  Introducing graphics transformations",
    "section": "",
    "text": "2.1 Translation\nLets begin with the easiest and simplest of all transformations, which is translation. A translation is used to move your object to a different position in the cartesian field.\nFigure 2.1 presents this transformation visually. The light blue rectangle represents the original position of the rectangle in the cartesian field. While the strong blue rectangle represents the position that the rectangle was moved after we applied the translation.\nBut how translation works? In summary, to translate an object, all you have to do is to add a “x offset” and a “y offset” to all vertices of your object. The “x offset” represents how much you want to move the object horizontally, while the “y offset” represents how much to move the object vertically.\nThe direction of the movement is determined by the fact if the offset you are adding is a positive or a negative number. For example, if you want to move your object to the right, then, you add a positive x offset to each x position. But if you want to move your object to the left instead, then, you add a negative x offset. The same logic applies to vertical movements.\nFor example, a triangle have three vertices. If we want to translate this triangle three points to the left, and two points up, then, we need to add the number 3 to the x position, and the number 2 to the y position of each vertex of this triangle.\nThe following code demonstrates this idea. We have a first triangle (object triangle), represented by the vertices \\((-1,0), (1,0), (0,2)\\). Then, we create a new triangle (object translated_triangle) that is translated by adding the “x offset” and “y offset” to each x and y positions, respectively.\nlibrary(ggplot2)\n\nWarning: package 'ggplot2' was built under R version 4.3.2\n\ntriangle &lt;- data.frame(\n  x = c(-1, 1, 0),\n  y = c(0, 0, 2)\n)\n\nx_offset &lt;- 3\ny_offset &lt;- 2\ntranslated_triangle &lt;- data.frame(\n  x = triangle$x + x_offset,\n  y = triangle$y + y_offset\n)\n\ncanvas &lt;- ggplot() +\n  theme_minimal() +\n  lims(y = c(-1, 5), x = c(-1, 5)) +\n  geom_vline(aes(xintercept = 0), color = \"#222222\") +\n  geom_hline(aes(yintercept = 0), color = \"#222222\")\n\ncanvas +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"Before translation\"),\n    data= triangle\n  ) +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"After translation\"),\n    data= translated_triangle\n  ) +\n  scale_fill_manual(values = c(\"#226ce3\", \"#a6c8ff\"))\nSo, if you need to translate any object in your image, you always need to do the same thing, which is to add x and y offsets to each coordinate/vertex of your object.\nHowever, the way you do this can vary depending on the specific geom you are using in your plot. Because different geoms in ggplot2 can treat the vertices of your object very differently.\nFor example, you can draw rectangles by using geom_rect() or geom_tile(). But these geoms are completely different in the way they draw the actual rectangle. geom_rect() draws a rectangle by using the coordinates of the four corners (or vertices) of the rectangle. In contrast, geom_tile() draw a rectangle by using a single coordinate (which is the center of the rectangle), plus a width and height values for the rectangle.\nThat sad, if you needed to translate a rectangle drawn by the geom_rect() geom, then, you do the same logic as the previous code example. But, in the other hand, is your rectangle is drawn by the geom_tile() geom, then, all you need to do is to translate a single coordinate (or vertex), which is the center point of the rectangle.\nr &lt;- data.frame(\n  center_x = 0.5,\n  center_y = 0.25,\n  width = 1,\n  height = 0.5\n)\n\nx_offset &lt;- 3\ny_offset &lt;- 2\ntranslated_r &lt;- data.frame(\n  center_x = r$center_x + 3,\n  center_y = r$center_y + 2,\n  width = 1,\n  height = 0.5\n)\n\ncanvas +\n  geom_tile(\n    aes(x = center_x, y = center_x,\n        height = height, width = width,\n        fill = \"Before translation\"),\n    data = r\n  ) +\n  geom_tile(\n    aes(x = center_x, y = center_x,\n        height = height, width = width,\n        fill = \"After translation\"),\n    data = translated_r\n  ) +\n  scale_fill_manual(values = c(\"#226ce3\", \"#a6c8ff\"))",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducing graphics transformations</span>"
    ]
  },
  {
    "objectID": "Chapters/01-transformations.html#translation",
    "href": "Chapters/01-transformations.html#translation",
    "title": "2  Introducing graphics transformations",
    "section": "",
    "text": "Figure 2.1: An example of translating an object in a cartesian field",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducing graphics transformations</span>"
    ]
  },
  {
    "objectID": "Chapters/01-transformations.html#scaling",
    "href": "Chapters/01-transformations.html#scaling",
    "title": "2  Introducing graphics transformations",
    "section": "2.2 Scaling",
    "text": "2.2 Scaling\nScaling is used to scale your object into a different size (i.e. to raise/shrink the size of your object). Figure 2.2 presents this process visually. We begin with the light blue and smaller triangle, and then, we scale this triangle into a bigger size, getting the strong blue triangle as a result.\n\n\n\n\n\n\nFigure 2.2: Scaling a triangle into a bigger size\n\n\n\nTo scale an object, we perform essentially the same thing that we did in translation, which was a simple math operation over the coordinates of the vertices that compose our object. But instead of adding offsets to the coordinates, we multiply each coordinate by a fixed amount/factor.\nAs an example, lets create a new triangle with the coordinates \\((0,0), (1,0), (0,2)\\). We can get a triangle that is twice bigger by multiplying each coordinate by a factor of two.\n\ntriangle &lt;- data.frame(\n  x = c(0, 1, 0),\n  y = c(0, 0, 2)\n)\ntwice_triangle &lt;- data.frame(\n  x = triangle$x * 2,\n  y = triangle$y * 2\n)\n\ncanvas +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"After scaling\"),\n    data= twice_triangle\n  ) +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"Before scaling\"),\n    data= triangle\n  ) +\n  scale_fill_manual(values = c(\"#226ce3\", \"#a6c8ff\"))\n\n\n\n\n\n\n\n\nIf you want to scale your object, but at the same time, keep the same center position as the original object, then, we need to perform two transformations at once: scaling and translation. We first scale the object to the size we want, and then, we translate this object to the same center position as the original object. Take this case as an example:\n\ntriangle &lt;- data.frame(\n  x = c(0.25, 1.5, 0.5),\n  y = c(0.5, 0.5, 2)\n)\ntwice_triangle &lt;- data.frame(\n  x = (triangle$x * 2) - (max(triangle$x) / 2),\n  y = (triangle$y * 2) - (max(triangle$y) / 2)\n)\n\ncanvas +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"After scaling\"),\n    data= twice_triangle\n  ) +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"Before scaling\"),\n    data= triangle\n  ) +\n  scale_fill_manual(values = c(\"#226ce3\", \"#a6c8ff\"))\n\n\n\n\n\n\n\n\nSo all you need to do is to multiply each coordinate by the factor you want to scale the object. If you want a bigger object, then, the factor must be a number greater than 1. But if you want a smaller object instead, then, the factor must be a number between 0 and 1. If you want an object that is half the original size, you should use the factor is 0.5.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducing graphics transformations</span>"
    ]
  },
  {
    "objectID": "Chapters/01-transformations.html#rotation",
    "href": "Chapters/01-transformations.html#rotation",
    "title": "2  Introducing graphics transformations",
    "section": "2.3 Rotation",
    "text": "2.3 Rotation\nRotation is used to rotate your object to a different angle. Figure 2.3 presents this transformation visually. We start with the light blue rectangle, which is parallel to the x axis, and then, we rotate this rectangle into a new angle, getting the strong blue rectangle as the result.\n\n\n\n\n\n\nFigure 2.3: Rotating a rectangle into a different angle\n\n\n\nRotating an object is a little more complicated than the other transformations. Only because it involves some magic calculations with a little of trigonometry.\nGiven a coordinate with \\(x\\) and \\(y\\) positions in a Cartesian plane, and a angle \\(A\\) in radians to rotate this initial coordinate, the new \\(x'\\) and \\(y'\\) positions can be calculated using the formulas below. \\(cos()\\) and \\(sin()\\) in these formulas are the cosine and sine trigonometric functions.\n\\[\nx' = x \\times cos(A) + y \\times - sin(A)\n\\tag{2.1}\\]\n\\[\ny' = x \\times sin(A) + y \\times cos(A)\n\\tag{2.2}\\]\nThis seems complicated, but, it actually is not. I mean really, you just have to follow these formulas above and you will be happy. But remember one detail about these formulas: the trigonometric functions cos() and sin() take as input angles that are in radians.\nWe usually think or talk about angles using the degrees measure (e.g. 90 degrees, 180 degrees, etc.). So you must convert your angle in degrees to radians, before you pass it to cos() and sin() functions. You can do this by using the function deg2rad() below, that uses the equation that we introduced at Chapter 1 to convert these measures. Notice that this function uses the PI value (i.e. the built-in pi object) to make this conversion.\n\n# A function to convert degrees to radians\ndeg2rad &lt;- function(deg){\n  return(deg * pi / 180)\n}\n\nAs a first example, lets take a triangle with coordinates \\((0,0), (1,0), (0,2)\\). Lets consider we wanted to perform two different rotations over this triangle. The first, we rotate it to 30 degrees clockwise, and in the second, 90 degrees clockwise.\n\ntriangle &lt;- data.frame(\n  x = c(0, 1, 0),\n  y = c(0, 0, 2)\n)\n\nangle &lt;- deg2rad(-30)\nfirst_rotated_triangle &lt;- data.frame(\n  x = (triangle$x * cos(angle)) + (triangle$y * -1 * sin(angle)),\n  y = (triangle$x * sin(angle)) + (triangle$y * cos(angle))\n)\n\nangle &lt;- deg2rad(-90)\nsecond_rotated_triangle &lt;- data.frame(\n  x = (triangle$x * cos(angle)) + (triangle$y * -1 * sin(angle)),\n  y = (triangle$x * sin(angle)) + (triangle$y * cos(angle))\n)\n\ncanvas +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"After second rotation\"),\n    data = second_rotated_triangle\n  ) +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"After first rotation\"),\n    data = first_rotated_triangle\n  ) +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"Before rotation\"),\n    data = triangle\n  ) +\n  scale_fill_manual(values = c(\"#226ce3\", \"#0c3a85\", \"#a6c8ff\"))\n\n\n\n\n\n\n\n\nOne important aspect about this operation, is that the above formulas (Equation 2.1 and Equation 2.2) rotate the object around the origin point of the Cartesian plane, i.e. coordinate \\((0, 0)\\).\nIn other words, the object is rotated around the origin point of the Cartesian plane, instead of rotating around the center point of the object, or, rotating around the leftmost vertex of the object, or around whatever other point you imagine.\nYou can see more clearly the effects of this fact by increasing the distance of your object from the origin point. In the example below, the same triangle and rotations as the previous example are used. But this time, the original triangle is further apart from the origin point (code is omitted for brevity reasons):",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducing graphics transformations</span>"
    ]
  },
  {
    "objectID": "Chapters/02-random.html",
    "href": "Chapters/02-random.html",
    "title": "3  Producing chaos in an ordered manner",
    "section": "",
    "text": "Stock prices are an example of chaos that exists in our economic system. For example, if tomorrow, Microsoft suffers a huge lost of investments (because of a wrong strategy, or some internal scandal, etc.), the stock prices of Apple will most likely go up. Apple did not had do to a thing! Its concurrent made a mistake, as a result, the price of its stock raised “automatically”, as a side-effect.\nAlso, huge and billionaire companies such as Apple have some degree of control over their stock price. In other words, these companies can inject huge amounts of money into the market, or, influence government decisions to slightly influence the price of their stocks. So when these big companies influence the market, we introduce a new effect on the table.\nSometimes we can predict some of these effects, specially if we have good sources of information inside the market. But there are so many effects (both in quantity and in quality), that becomes impossible to comprehend all of these effects at once, hence the “chaos feeling” that you feel when you work with the stock market.\nThis is frustrating for humans. We want to comprehend everything we are seeing! We want to know why, when, who and how everything happens. But at the same time, we as humans have limited resources: a limit amount of attention that we can spend, and limited brain processing power that we can spend when learning/understanding about something.\nThat is why some degree of order, or symmetry, or logic in a image is very pleasant to the eyes. Because is easy to understand a symmetric object. We can easily understand what we are seeing in the image.\nSo when you are building your generative art, you want some degree of chaos and randomness. But you also want to balance this chaos with some degree of order. Hence the current chapter title (producing chaos in an ordered manner).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Producing chaos in an ordered manner</span>"
    ]
  },
  {
    "objectID": "Chapters/01-angles.html#coordinate-systems",
    "href": "Chapters/01-angles.html#coordinate-systems",
    "title": "1  Coordinates, Angles and Objects",
    "section": "",
    "text": "Wickham, Hadley. 2016. Ggplot2: Elegant Graphics for Data Analysis. 2nd ed. Springer-Verlag New York. https://ggplot2-book.org/.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Coordinates, Angles and Objects</span>"
    ]
  }
]