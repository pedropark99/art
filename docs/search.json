[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Practical Generative Art with R and ggplot2: drawing with data",
    "section": "",
    "text": "Welcome\nWelcome! This is the initial page for the “Open Access” HTML version of the book “Practical Generative Art with R and ggplot2: drawing with data”, written by Pedro Duarte Faria.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#about-the-author",
    "href": "index.html#about-the-author",
    "title": "Practical Generative Art with R and ggplot2: drawing with data",
    "section": "About the author",
    "text": "About the author\nPedro Duarte Faria have a bachelor degree in Economics from Federal University of Ouro Preto - Brazil. Currently, he is a Data Engineer at Blip1, and an Associate Developer for Apache Spark 3.0 certified by Databricks.\nThe author have more than 3 years of experience in the data analysis market. He developed data pipelines, reports and analysis for research institutions and some of the largest companies in the brazilian financial sector, such as the BMG Bank, Sodexo and Pan Bank, besides dealing with databases that go beyond the billion rows.\nFurthermore, Pedro is specialized on the R programming language, and have given several lectures and courses about it, inside graduate centers (such as PPEA-UFOP2), in addition to federal and state organizations (such as FJP-MG3). As researcher, he have experience in the field of Science, Technology and Innovation Economics.\nPersonal Website: https://pedro-faria.netlify.app/\nTwitter: @PedroPark9\nMastodon: @pedropark99@fosstodon.org",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#books-metadata",
    "href": "index.html#books-metadata",
    "title": "Practical Generative Art with R and ggplot2: drawing with data",
    "section": "Book’s metadata",
    "text": "Book’s metadata\n\nLicense\nCopyright © 2024 Pedro Duarte Faria. This book is licensed by the CC-BY 4.0 Creative Commons Attribution 4.0 International Public License4.\n\n\n\nCorresponding author and maintainer\nPedro Duarte Faria\nContact: pedropark99@gmail.com\nPersonal website: https://pedro-faria.netlify.app/",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Practical Generative Art with R and ggplot2: drawing with data",
    "section": "",
    "text": "https://www.blip.ai/en/↩︎\nhttps://ppea.ufop.br/↩︎\nhttp://fjp.mg.gov.br/↩︎\nhttps://creativecommons.org/licenses/by/4.0/↩︎",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "Chapters/01-angles.html",
    "href": "Chapters/01-angles.html",
    "title": "1  Coordinates, Angles and Objects",
    "section": "",
    "text": "1.1 Describing some technical terms\nNow, I want to give you the meaning of some technical terms (a.k.a “jargons”) that I will frequently use across this book. I understand that not all readers of this book are familiarized with the world of computer graphics, and that is precisely why this section of the book exists.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Coordinates, Angles and Objects</span>"
    ]
  },
  {
    "objectID": "Chapters/01-angles.html#describing-some-technical-terms",
    "href": "Chapters/01-angles.html#describing-some-technical-terms",
    "title": "1  Coordinates, Angles and Objects",
    "section": "",
    "text": "1.1.1 Canvas\nThe term “canvas” comes from the world of painting. Canvas is essentially the surface area that you have available to paint your art. It is that blank and white board that we see all the time in films and photos, where the artist paint its art.\nIn computer graphics, the term canvas have essentially the same meaning. That is, canvas is the visual space of the image where we can draw things. We begin with a blank canvas, or a blank image, and we start drawing things into this space to form the graph, or the art we want to build.\n\n\n1.1.2 Plot vs Image\nThe R package ggplot2 is, essentially, a data visualization framework with focus on statistics, data exploration and data analysis. Because of that, users normally refer to the output of ggplot2 code, as a “plot”.\nSo I understand that some R and ggplot2 users might “cringe” when I use the word “image” instead of “plot”. Anyway, here in this book, I will use the words “plot” and “image” interchangeably. When you see the word “image” in this book, just interprets as “the ggplot2 code output”, or, as “the image that is produced by ggplot2”.\n\n\n1.1.3 Objects\nLet’s talk about what I consider as an “object” here in this book, because I will use this term very frequently. The word “object” in this book refers to any individual entity, object or shape that we draw into our image. In the example below, I am drawing three different objects/entities, which are: a rectangle, a line and a star.\nEach one of these three things that are draw to the image I consider as a different object or entity.\n\nlibrary(ggplot2)\n\nWarning: package 'ggplot2' was built under R version 4.3.2\n\nrectangle &lt;- data.frame(\n  x = c(0, 8, 8, 0),\n  y = c(0, 0, 2, 2)\n)\nline &lt;- data.frame(\n  x = c(0.67,12.3),\n  y = c(0.67,12.3)\n)\nstar &lt;- data.frame(\n  x = c(3, 4, 7, 4, 3, 2, -1, 2),\n  y = c(3, 6, 7, 8, 11, 8, 7, 6) + 1\n)\n\nggplot() +\n  geom_polygon(aes(x, y), fill = \"cyan\",\n            data = rectangle) +\n  geom_line(aes(x, y), data = line) +\n  geom_polygon(aes(x, y), fill = \"red\",\n               data = star)\n\n\n\n\n\n\n\n\n\n\n1.1.4 Vertices vs vertex\nVertices are the edge points of an object (or shape). Together, these edge points form a shape, an object, or a polygon in the screen. As an example, the rectangle below have 4 corners, each corner represents a different edge point.\nNow, “vertex” is a more obscure word for most peoples, and it actually have different meanings, depending on the area you are. In computer graphics, vertex is an object that contain attributes that describe something to be rendered into a scene. But in mathematics/geometry, a vertex indicate a point where two lines meet and form an angle.\nBecause of this polymorphism of the word, I will avoid to use the term “vertex” in this book. But if you do see this term anywhere in this book, you should know that I am using the meaning of vertex in the world of geometry. So a vertex, in the context of this book, is essentially the singular form of the word “vertices”, i.e. a vertex is a single edge point of an object.\n\n\n\n\n\n\nFigure 1.1: The vertices of a rectangle. A set of vertex’s form the vertices of an object",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Coordinates, Angles and Objects</span>"
    ]
  },
  {
    "objectID": "Chapters/01-angles.html#coordinate-systems",
    "href": "Chapters/01-angles.html#coordinate-systems",
    "title": "1  Coordinates, Angles and Objects",
    "section": "1.2 Coordinate systems",
    "text": "1.2 Coordinate systems\nThe coordinate system is the system that determines how an object will be positioned in the image, given a x and y positions. In other words, this system determines how the x and y positions are combined to position your object in the image.\nIn ggplot2 there are essentially 3 different coordinate systems, which are:\n\n\n\n\n\n\n\n\nFigure 1.2: The three coordinate systems available in ggplot2\n\n\n\n\n\nBy changing the coordinate system of your image, you change the way the objects are drawn and positioned in your image space (Wickham 2016). For example, a straight line will look straight in a Cartesian plane, but it will not look straight if we draw it in a non-linear coordinate system, such as the Polar coordinate system, which is a circular coordinate system.\nIn more details, the coordinates of a Polar coordinate system form a circumference around a center point, and as a consequence, if you draw any object in this coordinate system, this object will likely assume a round or circular shape, even if you did not have the intention of drawing something with this shape.\n\n1.2.1 The Cartesian plane\nBy default, ggplot2 always use the Cartesian coordinate system, which is created from the coord_cartesian() function. This is definitely the most familiar, and common type of coordinate system, because we see it all the time in real life.\nWe see this system in math class, when we learn about vectors and linear algebra, and also in most kinds of data visualizations (like scatter-plots or bar charts), and some types of maps too.\nThe Cartesian coordinate system is based on a two-dimensional coordinate plane, that is formed by the intersection of two perpendicular lines. The horizontal line is known as the “x axis”, and the vertical line is known as the “y axis”. These axis are also interpreted as the “height axis” (y) and “width axis” (x).\n\n\n\n\n\n\nFigure 1.3: Cartesian Plane. Source: Wikipedia, By K. Bolino - Made by K. Bolino (Kbolino), based upon earlier versions., Public Domain, https://commons.wikimedia.org/w/index.php?curid=869195\n\n\n\nA coordinate, or a point, or a position in the Cartesian plane is identified by a pair of values. The first value is the position in the “x axis”, and the second value is the position in the “y axis”. As an example, the coordinate \\((2, -8)\\) represents the point located at \\(x = 2\\) and \\(y = -8\\) in the plane. You could also interpret this coordinate as: it is the point located at two steps to the right, plus eight steps down.\nThe Cartesian coordinate system is originally a 2D coordinate system, meaning that it can be used to draw 2D images/graphics. But this system also supports 3D images/graphics by introducing a third axis (known as the “z axis”, or the “depth axis”) to the system. With this new axis, any coordinate in the plane becomes a set of 3 values: the x, y and z positions.\nIn this book, we are concerned with 2D graphics only, because the ggplot2 framework supports only 2D images/graphics. Because of that, I will not mention the “z axis” again. Any coordinate that I describe further in this book will use only the x and y axis in the Cartesian plane.\n\n\n1.2.2 Zooming into the Cartesian plane\nIf you need to, in ggplot2, you can zoom into a specific area of the Cartesian plane. But ggplot2 have two distinct notions of zoom that produces slightly different outputs.\nBoth approach’s of zoom consists in setting the limits (or ranges) of the values that will be displayed in the image. But you set these limits in different places: in the scale, or in the coordinate system. So you can zoom into an image by:\n\nLimiting the scale.\nLimiting the coordinates.\n\nIn ggplot2 we have scales. A scale control the details of how data values are translated to visual properties (Wickham et al. 2024). They take your data and turn it into something that you can see, like size, color, position or shape, and they also provide the tools that let you interpret the plot: the axes and legends (Wickham 2016).\nThe x and y axis are a type of scale, so you can control the limits of the x and y scales in your image, by setting the limits argument in scale_x_continuous() and scale_y_continuous() functions in your plot composition. Another alternative is the lims() function which is made for this operation.\nIf you set the limits of the x and y scales, what happens is that ggplot2 will zoom into that specific region you limited, but also, will omit (or ignore) any data that goes beyond these limits. Take the plot below as a start point, where we display three different lines, one above the other.\n\ndf &lt;- data.frame(\n  x = c(9, 10.5, 9.25, 10.75, 9.5, 11),\n  y = c(9, 10.5, 9.5, 11, 10, 11.5),\n  id = factor(c(1, 1, 2, 2, 3, 3))\n)\n\nggplot(df) +\n  geom_line(aes(x, y, group = id))\n\n\n\n\n\n\n\n\nLet’s suppose we wanted to apply a small zoom into this plot, to look closely at the center region of these lines, like 9.15 &lt; x &lt; 11.15 and 9.15 &lt; y &lt; 11.15 for example. If we try to zoom by limiting the scale, you can see that two of the three lines are removed from the plot.\n\nggplot(df) +\n  geom_line(aes(x, y, group = id)) +\n  lims(x = c(9.15, 11.15),\n       y = c(9.15, 11.15))\n\nWarning: Removed 2 rows containing missing values (`geom_line()`).\n\n\n\n\n\n\n\n\n\nWhat happened in this case, is that I’m setting the limits of the x and y scale from 9.15 to 11.15. This means that ggplot2 will plot only objects who’s x and y coordinates are between 9.15 and 11.15. If any x or y coordinate of an object is out of this range, then, the entire object is marked as “out of the scale limits”, and, as a consequence, ggplot2 completely ignores this object and its data.\nSo, in the above example, two of three lines were ignored by ggplot2, because at least one of the coordinates of these lines (for example, \\((9, 9)\\) and \\((11, 11.5)\\) were out of this 9.15 to 11.15 range.\nBut instead of setting the limits of the scale, you can set the limits of the coordinate system, i.e. the Cartesian plane. By setting the xlim and ylim arguments of the coord_cartesian() function. When you do that, ggplot2 just zooms into that specific area of the Cartesian plane that you specified, and any object that goes “out of bounds” are still preserved in the image, even though a section of the object is not visible.\n\nggplot(df) +\n  geom_line(aes(x, y, group = id)) +\n  coord_cartesian(\n    xlim = c(9.15, 11.15),\n    ylim = c(9.15, 11.15)\n  )\n\n\n\n\n\n\n\n\nSo in other words, when you limit the range of the scale, you are basically zooming into your plot, but at the same time, you are limiting the values you want to display in your plot. Is like you were specifying which values you want to plot, and which values you don’t want to plot.\nIn contrast, when you limit the Cartesian plane, then, you perform a “true zoom”, similar to when you zoom in a photo with a camera. Is like you were looking at a specific region of your plot under a magnifying glass.\n\n\n1.2.3 Other coordinate systems\nI will not talk at length about the other coordinate systems, because this book focus on the Cartesian plane. When I talk about coordinates here, most of the time I’m referring to a coordinate in a Cartesian plane.\nBut is worth to know that other coordinate systems exist in ggplot2. You can use any of the other two coordinate systems (Map or Polar system) by adding one of these functions to your plot composition:\n\ncoord_map()\ncoord_quickmap()\ncoord_polar()\n\nYou can draw maps (or geographic data in general) into a Cartesian plane if you want to. However, when we do that, a small distortion happens to the points/coordinates that compose the map, and this obviously affect the visual shape of the map.\nThis distortion happens essentially because geographic data is not based on a flat surface. Geographic data is based on two values, which are the latitude and longitude. These two values, or these two measures, represents a specific location in a spherical surface, which is the planet Earth.\nA Cartesian plane is flat surface (or a flat plane), like the surface of a dinner table. While the planet Earth, is a spherical surface, and this fact affects a lot on the way we see the objects that are drawn in this surface.\nThat means that, if we want to drawn a map precisely in a 2D image, we need to project this map into a 2D plane, by using the coord_map() or coord_quickmap() functions. These functions adjust the coordinates to account this spherical surface factor that is carried in the coordinates, and create a projection of your map over the 2D image. In other words, when you create a map projection, your image looks like as if you taken a photo of the planet Earth from a satellite.\nSo, in summary, you should never use coord_cartesian() to print maps in ggplot2. Instead, add coord_map() or coord_quickmap() to your image composition, like this:\n\nnzmap &lt;- maps::map(\"nz\", plot = FALSE)\nnzmap |&gt;\n  ggplot(aes(x = long, y = lat, group = group)) +\n  geom_polygon(fill = \"white\", colour = \"black\") +\n  coord_map(\n    \"azequalarea\",\n    orientation = c(-36.92, 174.6, 0)\n  )\n\n\n\n\n\n\n\n\nOn the other hand, the Polar coordinate system is a system based on two coordinates: angle and radius. These two measures are the back-bone of circles. That is why it is a circular coordinate system, and also why most of the things that you drawn in this system end up looking like circles.\n\ndf &lt;- data.frame(\n  angle = c(0, pi/2),\n  radius = c(5, 5)\n)\n\nggplot(df) +\n  geom_line(aes(angle, radius)) +\n  coord_polar()",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Coordinates, Angles and Objects</span>"
    ]
  },
  {
    "objectID": "Chapters/01-angles.html#angles-and-trigonometry",
    "href": "Chapters/01-angles.html#angles-and-trigonometry",
    "title": "1  Coordinates, Angles and Objects",
    "section": "1.3 Angles and trigonometry",
    "text": "1.3 Angles and trigonometry\nTrigonometry is the back-bone of circles. This is a really important topic in computer graphics, because is by using angles that we can rotate things in the computer screen, and is also by using trigonometry that we can draw curves.\nFirst, lets talk about angles. Angles, are usually measured in degrees (like 90 degrees, or 154 degrees), and is much easier for us, mere humans, to think about angles in this form. We learn in basic math that a complete turn in a circle is an angle of 360 degrees. As consequence, an angle measured in degrees is usually a number between 0 and 360, followed by the character ° (which is the degree symbol).\n\n1.3.1 The direction of the rotation\nBut one thing that not many people remember from math class, is that angles can also be negative. That is, an angle does not have to be a positive number, you can also have negative numbers, like an angle of -35 degrees. But when you change the signal of the number, you change the “direction” of the angle.\nIn more details, the signal of the angle (if it is a positive or negative number) defines the direction of the movement, or, the direction of the rotation that the angle performs. A negative angle makes a clockwise movement, while a positive angle, makes a counter-clockwise movement. Figure 1.4 presents this idea visually:\n\n\n\n\n\n\nFigure 1.4: The rotation direction in positive angles vs negative angles, values in degrees.\n\n\n\n\n\n1.3.2 Trigonometry and the Radians measure\nAlthough we are used to talk about angles using the degrees measure, in trigonometry, angles are measured using the radians measure. As consequence, every function used in trigonometry (like tangent or cosine) uses radians values as input.\nUsing radians instead of degrees to measure angles changes nothing about what the angle actually is, and it also changes nothing about how the signal of the angle changes the direction of the rotation made by that angle. This means that a negative radian value still represents a negative angle, that performs a clockwise movement, while a positive radian value represents the inverse of that.\nIn summary, the radians scale is completely based on the PI value, which is denoted by the \\(\\pi\\) symbol. If you ever need to use the PI value in R, you can simply use the built-in variable called pi that stores the PI value for you.\n\npi\n\n[1] 3.141593\n\n\nIn essence, \\(2\\pi\\) is equivalent to 360 degrees. So half of \\(2\\pi\\) would be equivalent to half of 360 degrees, which is 180 degrees. If we follow this logic, and convert all the angles showed at Figure 1.4 from degrees to radians, we get the following values:\n\nin_degrees &lt;- seq(-360, 360, by = 90)\nin_radians &lt;- (in_degrees / 360) * 2 * pi\nround(in_radians, 2)\n\n[1] -6.28 -4.71 -3.14 -1.57  0.00  1.57  3.14  4.71  6.28\n\n\n\n\n1.3.3 Convert degrees to angles and vice-versa\nLet’s establish a common formula to use when converting degrees values into radian values, and vice-versa. Given that \\(d\\) is an angle in degrees, and that \\(\\pi\\) represents the PI value, you can calculate the value in radians (\\(r\\)) that represents this exact same angle by following the formula below:\n\\[\nr = \\frac{d \\times \\pi}{180}\n\\tag{1.1}\\]\nYou can also do the inverse, which is to convert a angle in radians to degrees by following the formula below:\n\\[\nd = \\frac{r \\times 180}{\\pi}\n\\tag{1.2}\\]\nIf we take the formulas above, and transport them into R, we would get the functions deg2rad() and rad2deg() below:\n\n# A function to convert degrees into radians\ndeg2rad &lt;- function(deg){\n  return(deg * pi / 180)\n}\n# A function to convert radians into degrees\nrad2deg &lt;- function(rad){\n  return(rad * 180/ pi)\n}\n\n\n\n1.3.4 Calculate coordinates in a circle\nIf you want to draw a circle, you need to calculate the coordinates of the circumference of that circle, and with very little trigonometry, you can do that! You can calculate the coordinates of any point you want in the circumference of a circle.\nGiven that \\(Cx\\) and \\(Cy\\) are the x and y positions in the Cartesian plane where the circle’s center is, that \\(r\\) is the radius of the circle, and that \\(A\\) is the angle, in radians, that identifies the position in the circumference that you are trying to calculate its coordinates, you can calculate the x (\\(x'\\)) and y (\\(y'\\)) coordinates of the corresponding position in the circumference by using the following pair of equations:\n\\[\nx' = Cx + (r \\times \\cos(A));\n\\tag{1.3}\\]\n\\[\ny' = Cy + (r \\times \\sin(A));\n\\tag{1.4}\\]\nIf the circle you are trying to draw is centered at the origin point of the Cartesian plane, i.e. coordinate \\((0, 0)\\), then, \\(Cx = 0\\) and \\(Cy = 0\\), and, as a result, you can simplify the above formulas to \\(y'=r\\times \\sin(A)\\) and \\(x'=r\\times \\cos(A)\\).\nAs a first example, let’s suppose you wanted to calculate the coordinates of the very top of the circle, i.e. the highest point in the circle. If that is the case, then, the angle \\(A\\) should be \\(\\pi/2\\), which is 90 degrees counter-clockwise, or \\(-3\\pi/2\\), which is 270 degrees clockwise. Both angles represents the highest point in the circle as shown in Figure 1.4.\nNow, let’s also suppose that our circle have 5 units of radius, and it is centered in the origin point, so that we can use the simplified versions of Equation 1.3 and Equation 1.4. The code below calculates the coordinates of the “highest point” in this circle.\n\nx &lt;- round(5 * cos(pi/2), 5)\ny &lt;- round(5 * sin(pi/2), 5)\nglue::glue(\"x: {x}, y: {y}\")\n\nx: 0, y: 5\n\n\nSo in the example above, we used a single angle value (\\(\\pi/2\\)) to calculate the coordinates of a single point in the circumference of our circle. But to actually draw a circle in the plane, we need to calculate the coordinates of multiple points in the circumference, and then, connect all of them together to form a curve.\nThe code below demonstrates this idea. It starts by getting a sequence of angles (0, 10, 20, 30, … until 360). Then, it calculates the coordinates of the points in the circumference that are identified by each one of these angles in the sequence. Finally, we plot the calculated coordinates as points in the plane.\nYou can see in the plot below that, the points follow the shape of a circle. If you change the geom from geom_point() to geom_line(), then, you get an actual circle.\n\nangles &lt;- seq(0, 360, by = 10)\ncircle &lt;- data.frame(\n  x = 5 * cos(deg2rad(angles)),\n  y = 5 * sin(deg2rad(angles))\n)\n\nggplot(circle) + geom_point(aes(x, y))\n\n\n\n\n\n\n\n\n\n\n\n\nWickham, Hadley. 2016. Ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York. https://ggplot2.tidyverse.org.\n\n\nWickham, Hadley, Winston Chang, Lionel Henry, Thomas Lin Pedersen, Kohske Takahashi, Claus Wilke, Kara Woo, Hiroaki Yutani, and Dewey Dunnington. 2024. “Ggplot2 3.4.4 Official Documentation.” https://ggplot2.tidyverse.org/index.html.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Coordinates, Angles and Objects</span>"
    ]
  },
  {
    "objectID": "Chapters/01-transformations.html",
    "href": "Chapters/01-transformations.html",
    "title": "2  Introducing graphics transformations",
    "section": "",
    "text": "2.1 Translation\nLets begin with the easiest and simplest of all transformations, which is translation. A translation is used to move your object to a different position in the Cartesian field.\nFigure 2.1 presents this transformation visually. The light blue rectangle represents the original position of the rectangle in the Cartesian field. While the strong blue rectangle represents the new position where the original rectangle was moved to after we applied the translation.\nBut how translation works? In summary, to translate an object, all you have to do is to add a “x offset” and a “y offset” to all vertices of your object. The “x offset” represents how much you want to move the object horizontally, while the “y offset” represents how much to move the object vertically.\nThe direction of the movement is determined by the signal of the offset (i.e. if it is a positive or a negative number). For example, if you want to move your object to the right, then, you add a positive x offset to each x position. But if you want to move your object to the left instead, then, you add a negative x offset. The same logic applies to vertical movements.\nFor example, a triangle have three vertices. If we want to translate this triangle three points to the left, and two points up, then, we need to add the number 3 to the x position, and the number 2 to the y position of the three vertices of this triangle.\nThe following code demonstrates this idea. We have a first triangle (object triangle), represented by the vertices \\((-1,0), (1,0), (0,2)\\). Then, we create a new triangle (object translated_triangle) from the first one, by translating it with a x and y offsets to each x and y positions, respectively.\nlibrary(ggplot2)\n\nWarning: package 'ggplot2' was built under R version 4.3.2\n\ntriangle &lt;- data.frame(\n  x = c(-1, 1, 0),\n  y = c(0, 0, 2)\n)\n\nx_offset &lt;- 3\ny_offset &lt;- 2\ntranslated_triangle &lt;- data.frame(\n  x = triangle$x + x_offset,\n  y = triangle$y + y_offset\n)\n\ncanvas &lt;- ggplot() +\n  theme_minimal() +\n  lims(y = c(-1, 5), x = c(-1, 5)) +\n  geom_vline(aes(xintercept = 0), color = \"#222222\") +\n  geom_hline(aes(yintercept = 0), color = \"#222222\")\n\ncanvas +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"Before translation\"),\n    data= triangle\n  ) +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"After translation\"),\n    data= translated_triangle\n  ) +\n  scale_fill_manual(values = c(\"#226ce3\", \"#a6c8ff\"))\nSo, if you need to translate any object in your image, you always need to do the same thing, which is to add x and y offsets to the vertices of your object.\nHowever, the way you do this addition can vary depending on the specific geom you are using in your plot. Because different geoms in ggplot2 can treat the vertices of your object very differently. In other words, each geom can use very different strategies to actually build the object your describing with your data, and because of that, you might need to change the way you add these offsets to your data, to actually make the translation work properly.\nFor example, you can draw rectangles by using geom_rect() or geom_tile(). But these geoms are completely different in the way they draw the actual rectangle. geom_rect() draws a rectangle by using the coordinates of the four corners (or vertices) of the rectangle. In contrast, geom_tile() draw a rectangle by using a single coordinate (which is the center of the rectangle), plus the width and height of the rectangle.\nIf you needed to translate a rectangle drawn by the geom_rect() geom, then, you do the same logic as the previous code example. But, in the other hand, if your rectangle is drawn by the geom_tile() geom instead, then, all you need to do is to translate a single coordinate, which is the center point of the rectangle.\nr &lt;- data.frame(\n  center_x = 0.5,\n  center_y = 0.25,\n  width = 1,\n  height = 0.5\n)\n\nx_offset &lt;- 3\ny_offset &lt;- 2\ntranslated_r &lt;- data.frame(\n  center_x = r$center_x + 3,\n  center_y = r$center_y + 2,\n  width = 1,\n  height = 0.5\n)\n\ncanvas +\n  geom_tile(\n    aes(x = center_x, y = center_x,\n        height = height, width = width,\n        fill = \"Before translation\"),\n    data = r\n  ) +\n  geom_tile(\n    aes(x = center_x, y = center_x,\n        height = height, width = width,\n        fill = \"After translation\"),\n    data = translated_r\n  ) +\n  scale_fill_manual(values = c(\"#226ce3\", \"#a6c8ff\"))",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducing graphics transformations</span>"
    ]
  },
  {
    "objectID": "Chapters/01-transformations.html#translation",
    "href": "Chapters/01-transformations.html#translation",
    "title": "2  Introducing graphics transformations",
    "section": "",
    "text": "Figure 2.1: An example of translating an object in a Cartesian field",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducing graphics transformations</span>"
    ]
  },
  {
    "objectID": "Chapters/01-transformations.html#scaling",
    "href": "Chapters/01-transformations.html#scaling",
    "title": "2  Introducing graphics transformations",
    "section": "2.2 Scaling",
    "text": "2.2 Scaling\nScaling is used to scale your object into a different size (i.e. to raise/shrink the size of your object). Figure 2.2 presents this process visually. We begin with the light blue and smaller triangle, and then, we scale this triangle into a bigger size, getting the strong blue triangle as a result.\n\n\n\n\n\n\nFigure 2.2: Scaling a triangle into a bigger size\n\n\n\nTo scale an object, we perform essentially the same thing that we did in translation, which was a simple math operation over the coordinates of the vertices that compose our object. But instead of adding offsets to the coordinates, we multiply each coordinate by a fixed amount/factor.\nAs an example, lets create a new triangle with the coordinates \\((0,0), (1,0), (0,2)\\). We can get a triangle that is twice bigger by multiplying each coordinate by a factor of two.\n\ntriangle &lt;- data.frame(\n  x = c(0, 1, 0),\n  y = c(0, 0, 2)\n)\ntwice_triangle &lt;- data.frame(\n  x = triangle$x * 2,\n  y = triangle$y * 2\n)\n\ncanvas +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"After scaling\"),\n    data= twice_triangle\n  ) +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"Before scaling\"),\n    data= triangle\n  ) +\n  scale_fill_manual(values = c(\"#226ce3\", \"#a6c8ff\"))\n\n\n\n\n\n\n\n\nIf you want to scale your object, but at the same time, keep the same center position as the original object, then, we need to perform two transformations at once: scaling and translation. We first scale the object to the size we want, and then, we translate this object to the same center position as the original object. Take this case as an example:\n\ntriangle &lt;- data.frame(\n  x = c(0.25, 1.5, 0.5),\n  y = c(0.5, 0.5, 2)\n)\ntwice_triangle &lt;- data.frame(\n  x = (triangle$x * 2) - (max(triangle$x) / 2),\n  y = (triangle$y * 2) - (max(triangle$y) / 2)\n)\n\ncanvas +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"After scaling\"),\n    data= twice_triangle\n  ) +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"Before scaling\"),\n    data= triangle\n  ) +\n  scale_fill_manual(values = c(\"#226ce3\", \"#a6c8ff\"))\n\n\n\n\n\n\n\n\nSo all you need to do is to multiply each coordinate by the factor you want to scale the object. If you want a bigger object, then, the factor must be a number greater than 1. But if you want a smaller object instead, then, the factor must be a number between 0 and 1. For example, if you want an object that is half the original size, you should use the factor is 0.5.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducing graphics transformations</span>"
    ]
  },
  {
    "objectID": "Chapters/01-transformations.html#rotation",
    "href": "Chapters/01-transformations.html#rotation",
    "title": "2  Introducing graphics transformations",
    "section": "2.3 Rotation",
    "text": "2.3 Rotation\nRotation is a transformation used to rotate your object to a different angle. Figure 2.3 presents this transformation visually. We start with the light blue rectangle, which is parallel to the x axis, and then, we rotate this rectangle into a new angle, getting the strong blue rectangle as the result.\n\n\n\n\n\n\nFigure 2.3: Rotating a rectangle into a different angle\n\n\n\nRotating an object is a little more complicated than the other transformations. Only because it involves some magic calculations with a little of trigonometry.\nGiven a coordinate with \\(x\\) and \\(y\\) positions in a Cartesian plane, and a angle \\(A\\) in radians to rotate this initial coordinate, the new \\(x'\\) and \\(y'\\) positions of this coordinate after the rotation can be calculated using the formulas below. \\(\\cos()\\) and \\(\\sin()\\) in these formulas are the cosine and sine trigonometric functions.\n\\[\nx' = x \\times \\cos(A) + y \\times - \\sin(A)\n\\tag{2.1}\\]\n\\[\ny' = x \\times \\sin(A) + y \\times \\cos(A)\n\\tag{2.2}\\]\n\n2.3.1 Remember to convert your angles in degrees to radians\nThis seems complicated, but, it is actually not. I mean really, you just have to follow these formulas above and you will be happy. But remember one important detail about these formulas: the trigonometric functions cos() and sin() take as input angles that are in radians.\nThis is important, because we usually think or talk about angles using the degrees measure, which goes from -360 to 360 (e.g. 90 degrees, 180 degrees, etc.). So you must convert your angle in degrees to radians, before you pass it to cos() and sin() functions.\nYou can do this by using the function deg2rad() that we introduced at Chapter 1. To make life easier, the function definition is repeated below:\n\n# A function to convert degrees to radians\ndeg2rad &lt;- function(deg){\n  return(deg * pi / 180)\n}\n\n\n\n2.3.2 A first example of rotation\nAs a first example, lets take a triangle with coordinates \\((0,0), (1,0), (0,2)\\). Lets consider we wanted to perform two different rotations over this triangle. The first, we rotate it to 30 degrees clockwise, and in the second, 90 degrees clockwise.\n\ntriangle &lt;- data.frame(\n  x = c(0, 1, 0),\n  y = c(0, 0, 2)\n)\n\nangle &lt;- deg2rad(-30)\nfirst_rotated_triangle &lt;- data.frame(\n  x = (triangle$x * cos(angle)) + (triangle$y * -1 * sin(angle)),\n  y = (triangle$x * sin(angle)) + (triangle$y * cos(angle))\n)\n\nangle &lt;- deg2rad(-90)\nsecond_rotated_triangle &lt;- data.frame(\n  x = (triangle$x * cos(angle)) + (triangle$y * -1 * sin(angle)),\n  y = (triangle$x * sin(angle)) + (triangle$y * cos(angle))\n)\n\ncanvas +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"After second rotation\"),\n    data = second_rotated_triangle\n  ) +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"After first rotation\"),\n    data = first_rotated_triangle\n  ) +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"Before rotation\"),\n    data = triangle\n  ) +\n  scale_fill_manual(values = c(\"#226ce3\", \"#0c3a85\", \"#a6c8ff\"))\n\n\n\n\n\n\n\n\nAnother very important aspect about this operation, is that the above formulas (Equation 2.1 and Equation 2.2) calculate the new coordinates of the object considering the origin point of the Cartesian plane, i.e. coordinate \\((0, 0)\\) as the “center point of the rotation”.\nIn other words, instead of rotating around the center point of the object itself, or, rotating around the leftmost point of the vertices of the object, or around whatever other point you imagine, the object is rotated around the origin point of the Cartesian plane.\nYou can imagine this rotation as if the object followed the circumference of a circle that is centered in the origin point. The radius of the circle that is formed by this circumference is the actual distance that the object is from the origin point.\nYou can see this fact more clearly by increasing the distance of your object from the origin point. In the example below, the same triangle and rotation angles as the previous example are used. But this time, the original triangle is further apart from the origin point (code is omitted for brevity reasons). To help you visualize, I have also drawn the circle that is centered at the origin point. You can see that the rotated triangles follows the circumference of that circle.\n\n\n\n\n\n\n\n\n\n\n\n2.3.3 Rotating lines\nTherefore, you use Equation 2.1 and Equation 2.2 to calculate the new coordinates of a polygon that was rotated by a certain angle. But there is another pair of equations that you can use to calculate rotations, and you already saw them in this book, which is Equation 1.3 and Equation 1.4 that were presented in Chapter 1.\nThese two equations are useful in rotations because they are the easiest pair of equations to use when you want to rotate specifically a line, or a stroke if you prefer to call it this way.\nJust to be clear, you can in fact use Equation 2.1 and Equation 2.2 to calculate the new coordinates of a line after you rotated it by a certain angle. Is just that these equations are less intuitive than Equation 1.3 and Equation 1.4 for this specific case.\nLets begin our example with a line with coordinates \\((1.5, 0.6)\\) and \\((3.7, 2.7)\\). This line is exposed in the plot below:\n\nline &lt;- data.frame(\n  x = c(1.5, 3.7),\n  y = c(0.6, 2.7)\n)\n\ncanvas +\n  geom_line(aes(x,y), data = line)\n\n\n\n\n\n\n\n\nLets suppose you wanted to rotate this line 75 degrees counter-clockwise. How you do it? In this context, the variable \\(r\\) that is present at Equation 1.3 and Equation 1.4 becomes the length of the line. So, first, we calculate the line length.\nGiven that \\(l\\) is the line length that we want to calculate, and that \\(x_1\\) and \\(y_1\\) are the x and y positions of any of the endpoints of the line, and that \\(x_2\\) and \\(y_2\\) are the x and y positions of the other endpoint of the line, you can calculate the line length by following this formula:\n\\[\nl = \\sqrt{[(x_2 - x_1)^2 + (y_2 - y_1)^2]}\n\\tag{2.3}\\]\nIs important to emphasize, that you can choose whatever endpoint you want for \\(x_1\\) and \\(y_1\\). It can be the leftmost point of the line, or the rightmost. Once you choose the endpoint for \\(x_1\\) and \\(y_1\\), the endpoint for \\(x_2\\) and \\(y_2\\) automatically becomes the other endpoint.\nIn our example, lets use \\((1.5, 0.6)\\) as our endpoint 1, and \\((3.7, 2.7)\\) as our endpoint 2. With that, the line length is:\n\\[\nl = \\sqrt{(3.7 - 1.5)^2 + (2.7 - 0.6)^2}=3.041381\n\\]\nWe can obviously encapsulate Equation 2.3 into a nice R function that we can reuse whenever we want. If we do that, we get a function similar to line_length() below:\n\nline_length &lt;- function(x1, y1, x2, y2){\n  s1 &lt;- (x2 - x1)^2\n  s2 &lt;- (y2 - y1)^2\n  return(sqrt(s1 + s2))\n}\n\nline_length(1.5, 0.6, 3.7, 2.7)\n\n[1] 3.041381",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducing graphics transformations</span>"
    ]
  },
  {
    "objectID": "Chapters/02-random.html",
    "href": "Chapters/02-random.html",
    "title": "3  Producing chaos in an ordered manner",
    "section": "",
    "text": "Stock prices are an example of chaos that exists in our economic system. For example, if tomorrow, Microsoft suffers a huge lost of investments (because of a wrong strategy, or some internal scandal, etc.), the stock prices of Apple will most likely go up. Apple did not had do to a thing! Its concurrent made a mistake, as a result, the price of its stock raised “automatically”, as a side-effect.\nAlso, huge and billionaire companies such as Apple have some degree of control over their stock price. In other words, these companies can inject huge amounts of money into the market, or, influence government decisions to slightly influence the price of their stocks. So when these big companies influence the market, we introduce a new effect on the table.\nSometimes we can predict some of these effects, specially if we have good sources of information inside the market. But there are so many effects (both in quantity and in quality), that becomes impossible to comprehend all of these effects at once, hence the “chaos feeling” that you feel when you work with the stock market.\nThis is frustrating for humans. We want to comprehend everything we are seeing! We want to know why, when, who and how everything happens. But at the same time, we as humans have limited resources: a limit amount of attention that we can spend, and limited brain processing power that we can spend when learning/understanding about something.\nThat is why some degree of order, or symmetry, or logic in a image is very pleasant to the eyes. Because is easy to understand a symmetric object. We can easily understand what we are seeing in the image.\nSo when you are building your generative art, you want some degree of chaos and randomness. But you also want to balance this chaos with some degree of order. Hence the current chapter title (producing chaos in an ordered manner).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Producing chaos in an ordered manner</span>"
    ]
  }
]