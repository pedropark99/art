[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Practical Generative Art with R and ggplot2: drawing with data",
    "section": "",
    "text": "Welcome\nWelcome! This is the initial page for the “Open Access” HTML version of the book “Practical Generative Art with R and ggplot2: drawing with data”, written by Pedro Duarte Faria.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#about-the-author",
    "href": "index.html#about-the-author",
    "title": "Practical Generative Art with R and ggplot2: drawing with data",
    "section": "About the author",
    "text": "About the author\nPedro Duarte Faria have a bachelor degree in Economics from Federal University of Ouro Preto - Brazil. Currently, he is a Data Engineer at Blip1, and an Associate Developer for Apache Spark 3.0 certified by Databricks.\nThe author have more than 3 years of experience in the data analysis market. He developed data pipelines, reports and analysis for research institutions and some of the largest companies in the brazilian financial sector, such as the BMG Bank, Sodexo and Pan Bank, besides dealing with databases that go beyond the billion rows.\nFurthermore, Pedro is specialized on the R programming language, and have given several lectures and courses about it, inside graduate centers (such as PPEA-UFOP2), in addition to federal and state organizations (such as FJP-MG3). As researcher, he have experience in the field of Science, Technology and Innovation Economics.\nPersonal Website: https://pedro-faria.netlify.app/\nTwitter: @PedroPark9\nMastodon: @pedropark99@fosstodon.org",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#books-metadata",
    "href": "index.html#books-metadata",
    "title": "Practical Generative Art with R and ggplot2: drawing with data",
    "section": "Book’s metadata",
    "text": "Book’s metadata\n\nLicense\nCopyright © 2024 Pedro Duarte Faria. This book is licensed by the CC-BY 4.0 Creative Commons Attribution 4.0 International Public License4.\n\n\n\nCorresponding author and maintainer\nPedro Duarte Faria\nContact: pedropark99@gmail.com\nPersonal website: https://pedro-faria.netlify.app/",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Practical Generative Art with R and ggplot2: drawing with data",
    "section": "",
    "text": "https://www.blip.ai/en/↩︎\nhttps://ppea.ufop.br/↩︎\nhttp://fjp.mg.gov.br/↩︎\nhttps://creativecommons.org/licenses/by/4.0/↩︎",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "Chapters/01-angles.html#describing-some-technical-terms",
    "href": "Chapters/01-angles.html#describing-some-technical-terms",
    "title": "1  Coordinates, Angles and Objects",
    "section": "1.1 Describing some technical terms",
    "text": "1.1 Describing some technical terms\nNow, I want to give you the meaning of some technical terms (a.k.a “jargons”) that I will frequently use across this book. I understand that not all readers of this book are familiarized with the world of computer graphics, and that is precisely why this section of the book exists.\n\n1.1.1 Canvas\nThe term “canvas” comes from the world of painting. Canvas is essentially the surface area that you have available to paint your art. It is that blank and white board that we see all the time in films and photos, where the artist paint its art.\nIn computer graphics, the term canvas have essentially the same meaning. That is, canvas is the visual space of the image where we can draw things. We begin with a blank canvas, or a blank image, and we start drawing things into this space to form the graph, or the art we want to build.\n\n\n1.1.2 Plot vs Image\nThe R package ggplot2 is, essentially, a data visualization framework with focus on statistics, data exploration and data analysis. Because of that, users normally refer to the output of ggplot2 code, as a “plot”.\nSo I understand that some R and ggplot2 users might “cringe” when I use the word “image” instead of “plot”. Anyway, here in this book, I will use the words “plot” and “image” interchangeably. When you see the word “image” in this book, just interprets as “the ggplot2 code output”, or, as “the image that is produced by ggplot2”.\n\n\n1.1.3 Objects\nLet’s talk about what I consider as an “object” here in this book, because I will use this term very frequently. The word “object” in this book refers to any individual entity, object or shape that we draw into our image. In the example below, I am drawing three different objects/entities, which are: a rectangle, a line and a star.\nEach one of these three things that are draw to the image I consider as a different object or entity.\n\nlibrary(ggplot2)\n\nWarning: package 'ggplot2' was built under R version 4.3.2\n\nlibrary(tibble)\nrectangle &lt;- tibble(\n  x = c(0, 8, 8, 0),\n  y = c(0, 0, 2, 2)\n)\nline &lt;- tibble(\n  x = c(0.67,12.3),\n  y = c(0.67,12.3)\n)\nstar &lt;- tibble(\n  x = c(3, 4, 7, 4, 3, 2, -1, 2),\n  y = c(3, 6, 7, 8, 11, 8, 7, 6) + 1\n)\n\nggplot() +\n  geom_polygon(aes(x, y), fill = \"cyan\",\n            data = rectangle) +\n  geom_line(aes(x, y), data = line) +\n  geom_polygon(aes(x, y), fill = \"red\",\n               data = star)\n\n\n\n\n\n\n\n\n\n\n1.1.4 Vertices vs vertex\nVertices are the edge points of an object (or shape). Together, these edge points form a shape, an object, or a polygon in the screen. As an example, the rectangle below have 4 corners, each corner represents a different edge point.\nNow, “vertex” is a more obscure word for most peoples, and it actually have different meanings, depending on the area you are. In computer graphics, vertex is an object that contain attributes that describe something to be rendered into a scene. But in mathematics/geometry, a vertex indicate a point where two lines meet and form an angle.\nBecause of this polymorphism of the word, I will avoid to use the term “vertex” in this book. But if you do see this term anywhere in this book, you should know that I am using the meaning of vertex in the world of geometry. So a vertex, in the context of this book, is essentially the singular form of the word “vertices”, i.e. a vertex is a single edge point of an object.\n\n\n\n\n\n\nFigure 1.1: The vertices of a rectangle. A set of vertex’s form the vertices of an object",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Coordinates, Angles and Objects</span>"
    ]
  },
  {
    "objectID": "Chapters/01-angles.html#coordinate-systems",
    "href": "Chapters/01-angles.html#coordinate-systems",
    "title": "1  Coordinates, Angles and Objects",
    "section": "1.2 Coordinate systems",
    "text": "1.2 Coordinate systems\nThe coordinate system is the system that determines how an object will be positioned in the image, given a x and y positions. In other words, this system determines how the x and y positions are combined to position your object in the image.\nIn ggplot2 there are essentially 3 different coordinate systems, which are:\n\n\n\n\n\n\n\n\nFigure 1.2: The three coordinate systems available in ggplot2\n\n\n\n\n\nBy changing the coordinate system of your image, you change the way the objects are drawn and positioned in your image space (Wickham 2016). For example, a straight line will look straight in a Cartesian plane, but it will not look straight if we draw it in a non-linear coordinate system, such as the Polar coordinate system, which is a circular coordinate system.\nIn more details, the coordinates of a Polar coordinate system form a circumference around a center point, and as a consequence, if you draw any object in this coordinate system, this object will likely assume a round or circular shape, even if you did not have the intention of drawing something with this shape.\n\n1.2.1 The Cartesian plane\nBy default, ggplot2 always use the Cartesian coordinate system, which is created from the coord_cartesian() function. This is definitely the most familiar, and common type of coordinate system, because we see it all the time in real life.\nWe see this system in math class, when we learn about vectors and linear algebra, and also in most kinds of data visualizations (like scatter-plots or bar charts), and some types of maps too.\nThe Cartesian coordinate system is based on a two-dimensional coordinate plane, that is formed by the intersection of two perpendicular lines. The horizontal line is known as the “x axis”, and the vertical line is known as the “y axis”. These axis are also interpreted as the “height axis” (y) and “width axis” (x).\n\n\n\n\n\n\nFigure 1.3: Cartesian Plane. Source: Wikipedia, By K. Bolino - Made by K. Bolino (Kbolino), based upon earlier versions., Public Domain, https://commons.wikimedia.org/w/index.php?curid=869195\n\n\n\nA coordinate, or a point, or a position in the Cartesian plane is identified by a pair of values. The first value is the position in the “x axis”, and the second value is the position in the “y axis”. As an example, the coordinate \\((2, -8)\\) represents the point located at \\(x = 2\\) and \\(y = -8\\) in the plane. You could also interpret this coordinate as: it is the point located at two steps to the right, plus eight steps down.\nThe Cartesian coordinate system is originally a 2D coordinate system, meaning that it can be used to draw 2D images/graphics. But this system also supports 3D images/graphics by introducing a third axis (known as the “z axis”, or the “depth axis”) to the system. With this new axis, any coordinate in the plane becomes a set of 3 values: the x, y and z positions.\nIn this book, we are concerned with 2D graphics only, because the ggplot2 framework supports only 2D images/graphics. Because of that, I will not mention the “z axis” again. Any coordinate that I describe further in this book will use only the x and y axis in the Cartesian plane.\n\n\n1.2.2 Zooming into the Cartesian plane\nIf you need to, in ggplot2, you can zoom into a specific area of the Cartesian plane. But ggplot2 have two distinct notions of zoom that produces slightly different outputs.\nBoth approach’s of zoom consists in setting the limits (or ranges) of the values that will be displayed in the image. But you set these limits in different places: in the scale, or in the coordinate system. So you can zoom into an image by:\n\nLimiting the scale.\nLimiting the coordinates.\n\nIn ggplot2 we have scales. A scale control the details of how data values are translated to visual properties (Wickham et al. 2024). They take your data and turn it into something that you can see, like size, color, position or shape, and they also provide the tools that let you interpret the plot: the axes and legends (Wickham 2016).\nThe x and y axis are a type of scale, so you can control the limits of the x and y scales in your image, by setting the limits argument in scale_x_continuous() and scale_y_continuous() functions in your plot composition. Another alternative is the lims() function which is made for this operation.\nIf you set the limits of the x and y scales, what happens is that ggplot2 will zoom into that specific region you limited, but also, will omit (or ignore) any data that goes beyond these limits. Take the plot below as a start point, where we display three different lines, one above the other.\n\ndf &lt;- tibble(\n  x = c(9, 10.5, 9.25, 10.75, 9.5, 11),\n  y = c(9, 10.5, 9.5, 11, 10, 11.5),\n  id = factor(c(1, 1, 2, 2, 3, 3))\n)\n\nggplot(df) +\n  geom_line(aes(x, y, group = id))\n\n\n\n\n\n\n\n\nLet’s suppose we wanted to apply a small zoom into this plot, to look closely at the center region of these lines, like 9.15 &lt; x &lt; 11.15 and 9.15 &lt; y &lt; 11.15 for example. If we try to zoom by limiting the scale, you can see that two of the three lines are removed from the plot.\n\nggplot(df) +\n  geom_line(aes(x, y, group = id)) +\n  lims(x = c(9.15, 11.15),\n       y = c(9.15, 11.15))\n\nWarning: Removed 2 rows containing missing values (`geom_line()`).\n\n\n\n\n\n\n\n\n\nWhat happened in this case, is that I’m setting the limits of the x and y scale from 9.15 to 11.15. This means that ggplot2 will plot only objects who’s x and y coordinates are between 9.15 and 11.15. If any x or y coordinate of an object is out of this range, then, the entire object is marked as “out of the scale limits”, and, as a consequence, ggplot2 completely ignores this object and its data.\nSo, in the above example, two of three lines were ignored by ggplot2, because at least one of the coordinates of these lines (for example, \\((9, 9)\\) and \\((11, 11.5)\\) were out of this 9.15 to 11.15 range.\nBut instead of setting the limits of the scale, you can set the limits of the coordinate system, i.e. the Cartesian plane. By setting the xlim and ylim arguments of the coord_cartesian() function. When you do that, ggplot2 just zooms into that specific area of the Cartesian plane that you specified, and any object that goes “out of bounds” are still preserved in the image, even though a section of the object is not visible.\n\nggplot(df) +\n  geom_line(aes(x, y, group = id)) +\n  coord_cartesian(\n    xlim = c(9.15, 11.15),\n    ylim = c(9.15, 11.15)\n  )\n\n\n\n\n\n\n\n\nSo in other words, when you limit the range of the scale, you are basically zooming into your plot, but at the same time, you are limiting the values you want to display in your plot. Is like you were specifying which values you want to plot, and which values you don’t want to plot.\nIn contrast, when you limit the Cartesian plane, then, you perform a “true zoom”, similar to when you zoom in a photo with a camera. Is like you were looking at a specific region of your plot under a magnifying glass.\n\n\n1.2.3 Other coordinate systems\nI will not talk at length about the other coordinate systems, because this book focus on the Cartesian plane. When I talk about coordinates here, most of the time I’m referring to a coordinate in a Cartesian plane.\nBut is worth to know that other coordinate systems exist in ggplot2. You can use any of the other two coordinate systems (Map or Polar system) by adding one of these functions to your plot composition:\n\ncoord_map()\ncoord_quickmap()\ncoord_polar()\n\nYou can draw maps (or geographic data in general) into a Cartesian plane if you want to. However, when we do that, a small distortion happens to the points/coordinates that compose the map, and this obviously affect the visual shape of the map.\nThis distortion happens essentially because geographic data is not based on a flat surface. Geographic data is based on two values, which are the latitude and longitude. These two values, or these two measures, represents a specific location in a spherical surface, which is the planet Earth.\nA Cartesian plane is flat surface (or a flat plane), like the surface of a dinner table. While the planet Earth, is a spherical surface, and this fact affects a lot on the way we see the objects that are drawn in this surface.\nThat means that, if we want to drawn a map precisely in a 2D image, we need to project this map into a 2D plane, by using the coord_map() or coord_quickmap() functions. These functions adjust the coordinates to account this spherical surface factor that is carried in the coordinates, and create a projection of your map over the 2D image. In other words, when you create a map projection, your image looks like as if you taken a photo of the planet Earth from a satellite.\nSo, in summary, you should never use coord_cartesian() to print maps in ggplot2. Instead, add coord_map() or coord_quickmap() to your image composition, like this:\n\nnzmap &lt;- maps::map(\"nz\", plot = FALSE)\nnzmap |&gt;\n  ggplot(aes(x = long, y = lat, group = group)) +\n  geom_polygon(fill = \"white\", colour = \"black\") +\n  coord_map(\n    \"azequalarea\",\n    orientation = c(-36.92, 174.6, 0)\n  )\n\n\n\n\n\n\n\n\nOn the other hand, the Polar coordinate system is a system based on two coordinates: angle and radius. These two measures are the back-bone of circles. That is why it is a circular coordinate system, and also why most of the things that you drawn in this system end up looking like circles.\n\ndf &lt;- tibble(\n  angle = c(0, pi/2),\n  radius = c(5, 5)\n)\n\nggplot(df) +\n  geom_line(aes(angle, radius)) +\n  coord_polar()",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Coordinates, Angles and Objects</span>"
    ]
  },
  {
    "objectID": "Chapters/01-angles.html#angles-and-trigonometry",
    "href": "Chapters/01-angles.html#angles-and-trigonometry",
    "title": "1  Coordinates, Angles and Objects",
    "section": "1.3 Angles and trigonometry",
    "text": "1.3 Angles and trigonometry\nTrigonometry is the back-bone of circles. This is a really important topic in computer graphics, because is by using angles that we can rotate things in the computer screen, and is also by using trigonometry that we can draw curves.\nFirst, lets talk about angles. Angles, are usually measured in degrees (like 90 degrees, or 154 degrees), and is much easier for us, mere humans, to think about angles in this form. We learn in basic math that a complete turn in a circle is an angle of 360 degrees. As consequence, an angle measured in degrees is usually a number between 0 and 360, followed by the character ° (which is the degree symbol).\n\n1.3.1 The direction of the rotation\nBut one thing that not many people remember from math class, is that angles can also be negative. That is, an angle does not have to be a positive number, you can also have negative numbers, like an angle of -35 degrees. But when you change the signal of the number, you change the “direction” of the angle.\nIn more details, the signal of the angle (if it is a positive or negative number) defines the direction of the movement, or, the direction of the rotation that the angle performs. A negative angle makes a clockwise movement, while a positive angle, makes a counter-clockwise movement. Figure 1.4 presents this idea visually:\n\n\n\n\n\n\nFigure 1.4: The rotation direction in positive angles vs negative angles, values in degrees.\n\n\n\n\n\n1.3.2 Trigonometry and the Radians measure\nAlthough we are used to talk about angles using the degrees measure, in trigonometry, angles are measured in radians. As consequence, every function used in trigonometry (like tangent or cosine) uses radians values as input, instead of degrees values.\nUsing radians instead of degrees to measure angles changes nothing about what the angle actually is, and it also changes nothing about how the signal of the angle changes the direction of the rotation made by that angle, as I showed at Section 1.3.1.\nRadians is just a different scale, with a different range of values. This means that a negative radian value still represents a negative angle, that performs a clockwise movement, while a positive radian value represents a positive angle, that performs a counter-clockwise movement.\nIn summary, the radians scale is completely based on the PI value, which is denoted by the \\(\\pi\\) symbol. If you ever need to use the PI value in R, you can simply use the built-in variable called pi that stores the PI value for you.\n\npi\n\n[1] 3.141593\n\n\nIn essence, we learn in basic math that \\(2\\pi\\) is equivalent to 360 degrees. So half of \\(2\\pi\\) would be equivalent to half of 360 degrees, which is 180 degrees. If we follow this logic, and convert all the angles showed at Figure 1.4 from degrees to radians, we get the following values:\n\nin_degrees &lt;- seq(-360, 360, by = 90)\nin_radians &lt;- (in_degrees / 360) * (2 * pi)\nround(in_radians, 2)\n\n[1] -6.28 -4.71 -3.14 -1.57  0.00  1.57  3.14  4.71  6.28\n\n\n\n\n1.3.3 Convert degrees into radians and vice-versa\nLet’s establish a common formula to use when converting degrees values into radians values, and vice-versa. Given that \\(d\\) is an angle in degrees, and that \\(\\pi\\) represents the PI value, you can calculate the value in radians (\\(r\\)) that represents this exact same angle by following the formula below:\n\\[\nr = \\frac{d \\times \\pi}{180}\n\\tag{1.1}\\]\nYou can also do the inverse, which is to convert a angle in radians to degrees by following this formula:\n\\[\nd = \\frac{r \\times 180}{\\pi}\n\\tag{1.2}\\]\nIf we take the formulas above, and transport them into R, we would get the functions deg2rad() and rad2deg() below:\n\n# A function to convert degrees into radians\ndeg2rad &lt;- function(deg){\n  return(deg * pi / 180)\n}\n# A function to convert radians into degrees\nrad2deg &lt;- function(rad){\n  return(rad * 180/ pi)\n}\n\n\n\n1.3.4 Trigonometric functions\nTrigonometry is the field of mathematics that study angles and their relationships between each other. In this field, three essential functions were developed:\n\ncosine (usually written as \\(\\cos()\\));\nsine (usually written as \\(\\sin()\\));\ntangent (usually written as \\(\\tan()\\));\n\nThese three functions were originally born from the ratios between the edges of a right triangle. But you can use them to make fancy calculations with angles, and that is the essential part.\nWe will use these functions extensively in this book, so you should get familiarized with them. Because without them, we cannot draw circles or rotate objects in the screen.\nEach one of these three trigonometric functions are present in R as built-in functions. In other words, these functions are exported from base R. And all of them receives an angle, in radians, as input.\n\ncos() for cosine;\nsin() for sine;\ntan() for tangent;\n\nWe also have an inverse function for each of one of these three main trigonometric functions. These functions are commonly referred to as the “arc functions”.\n\nacos() for arc-cosine (inverse of cosine);\nasin() for arc-sine (inverse of sine);\natan() and atan2() for arc-tangent (inverse of tangent);\n\n\n\n1.3.5 Calculate coordinates in a circle\nIf you want to draw a circle, you need first to calculate the coordinates of the circumference of this circle, and with very little trigonometry, you can do that! You can calculate the coordinates of any point you want in the circumference of a circle.\nGiven that \\(Cx\\) and \\(Cy\\) are the x and y positions in the Cartesian plane where the circle’s center is, that \\(r\\) is the radius of the circle, and that \\(A\\) is the angle, in radians, that identifies the position in the circumference that you are trying to calculate its coordinates, you can calculate the x (\\(x'\\)) and y (\\(y'\\)) coordinates of the corresponding position in the circumference by using the following pair of equations:\n\\[\nx' = Cx + (r \\times \\cos(A));\n\\tag{1.3}\\]\n\\[\ny' = Cy + (r \\times \\sin(A));\n\\tag{1.4}\\]\nIf the circle you are trying to draw is centered at the origin point of the Cartesian plane, i.e. coordinate \\((0, 0)\\), then, \\(Cx = 0\\) and \\(Cy = 0\\), and, as a result, you can simplify the above formulas to \\(y'=r\\times \\sin(A)\\) and \\(x'=r\\times \\cos(A)\\).\nAs a first example, let’s use a circle with 5 points of radius, and that is centered at the origin point. If you want to calculate the coordinates of the circumference at angles 35 degrees, and 68 degrees for example, you would get approximately the coordinates \\((4.10, 2.87)\\) and \\((1.87, 4.64)\\), as you can see below:\n\nx &lt;- 5 * cos(deg2rad( c(35, 68) ))\ny &lt;- 5 * sin(deg2rad( c(35, 68) ))\nprint(x)\n\n[1] 4.095760 1.873033\n\nprint(y)\n\n[1] 2.867882 4.635919\n\n\nAt Figure 1.5 you can visualize what these coordinates are, and how they relate back to the circle in the Cartesian plane:\n\n\n\n\n\n\n\n\nFigure 1.5: Calculating coordinates in the circumference of a circle\n\n\n\n\n\nAs a second example, let’s suppose you wanted to calculate the coordinates of the very top of the circle, i.e. the highest point in the circle. If that is the case, then, the angle \\(A\\) should be \\(\\pi/2\\), which is 90 degrees counter-clockwise, or \\(-3\\pi/2\\), which is 270 degrees clockwise. Both angles represents the highest point in the circle as shown in Figure 1.4.\nLet’s also suppose that our circle have 5 units of radius, and that it is centered in the origin point, so that we can use the simplified versions of Equation 1.3 and Equation 1.4. The code below calculates the coordinates of the “highest point” in this circle.\n\nx &lt;- round(5 * cos(pi/2), 5)\ny &lt;- round(5 * sin(pi/2), 5)\nglue::glue(\"x: {x}, y: {y}\")\n\nx: 0, y: 5\n\n\nSo in the example above, we used a single angle value (\\(\\pi/2\\)) to calculate the coordinates of a single point in the circumference of our circle. But to actually draw a circle in the plane, we need to calculate the coordinates of several points in the circumference, and then, connect all of them together to draw the circumference.\nThe code below demonstrates this idea. It starts by getting a sequence of angles (0, 10, 20, 30, … until 360). Then, it calculates the coordinates of the points in the circumference that are identified by each one of these angles in the sequence. Finally, we plot the calculated coordinates as points in the plane.\nYou can see in the plot below that, the points follow the shape of a circle. If you change the geom from geom_point() to geom_path(), then, you get an actual circle.\n\nangles &lt;- seq(0, 360, by = 10)\nangles &lt;- deg2rad(angles)\ncircle &lt;- tibble(\n  x = 5 * cos(angles),\n  y = 5 * sin(angles)\n)\n\nggplot(circle) + geom_point(aes(x, y))\n\n\n\n\n\n\n\n\n\n\n\n\nWickham, Hadley. 2016. Ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York. https://ggplot2.tidyverse.org.\n\n\nWickham, Hadley, Winston Chang, Lionel Henry, Thomas Lin Pedersen, Kohske Takahashi, Claus Wilke, Kara Woo, Hiroaki Yutani, and Dewey Dunnington. 2024. “Ggplot2 3.4.4 Official Documentation.” https://ggplot2.tidyverse.org/index.html.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Coordinates, Angles and Objects</span>"
    ]
  },
  {
    "objectID": "Chapters/01-transformations.html#sec-translation",
    "href": "Chapters/01-transformations.html#sec-translation",
    "title": "2  Introducing graphics transformations",
    "section": "2.1 Translation",
    "text": "2.1 Translation\nLets begin with the easiest and simplest of all transformations, which is translation. A translation is used to move your object to a different position in the Cartesian field.\nFigure 2.1 presents this transformation visually. The light blue rectangle represents the original position of the rectangle in the Cartesian field. While the strong blue rectangle represents the new position where the original rectangle was moved to after we applied the translation.\n\n\n\n\n\n\nFigure 2.1: An example of translating an object in a Cartesian field\n\n\n\nBut how translation works? In summary, to translate an object, all you have to do is to add a “x offset” and a “y offset” to all vertices of your object. The “x offset” represents how much you want to move the object horizontally, while the “y offset” represents how much to move the object vertically.\nThe direction of the movement is determined by the signal of the offset (i.e. if it is a positive or a negative number). For example, if you want to move your object to the right, then, you add a positive x offset to each x position. But if you want to move your object to the left instead, then, you add a negative x offset. The same logic applies to vertical movements.\nFor example, a triangle have three vertices. If we want to translate this triangle three points to the left, and two points up, then, we need to add the number 3 to the x position, and the number 2 to the y position of the three vertices of this triangle.\nThe following code demonstrates this idea. We have a first triangle (object triangle), represented by the vertices \\((-1,0), (1,0), (0,2)\\). Then, we create a new triangle (object translated_triangle) from the first one, by translating it with a x and y offsets to each x and y positions, respectively.\n\nlibrary(ggplot2)\n\nWarning: package 'ggplot2' was built under R version 4.3.2\n\nlibrary(tibble)\n\ntriangle &lt;- tibble(\n  x = c(-1, 1, 0),\n  y = c(0, 0, 2)\n)\n\nx_offset &lt;- 3\ny_offset &lt;- 2\ntranslated_triangle &lt;- tibble(\n  x = triangle$x + x_offset,\n  y = triangle$y + y_offset\n)\n\ncanvas &lt;- ggplot() +\n  theme_minimal() +\n  lims(y = c(-1, 5), x = c(-1, 5)) +\n  geom_vline(aes(xintercept = 0), color = \"#222222\") +\n  geom_hline(aes(yintercept = 0), color = \"#222222\")\n\ncanvas +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"Before translation\"),\n    data= triangle\n  ) +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"After translation\"),\n    data= translated_triangle\n  ) +\n  scale_fill_manual(values = c(\"#226ce3\", \"#a6c8ff\"))\n\n\n\n\n\n\n\n\nSo, if you need to translate any object in your image, you always need to do the same thing, which is to add x and y offsets to the vertices of your object.\nHowever, the way you do this addition can vary depending on the specific geom you are using in your plot. Because different geoms in ggplot2 can treat the vertices of your object very differently. In other words, each geom can use very different strategies to actually build the object your describing with your data, and because of that, you might need to change the way you add these offsets to your data, to actually make the translation work properly.\nFor example, you can draw rectangles by using geom_rect() or geom_tile(). But these geoms are completely different in the way they draw the actual rectangle. geom_rect() draws a rectangle by using the coordinates of the four corners (or vertices) of the rectangle. In contrast, geom_tile() draw a rectangle by using a single coordinate (which is the center of the rectangle), plus the width and height of the rectangle.\nIf you needed to translate a rectangle drawn by the geom_rect() geom, then, you do the same logic as the previous code example. But, in the other hand, if your rectangle is drawn by the geom_tile() geom instead, then, all you need to do is to translate a single coordinate, which is the center point of the rectangle.\n\nr &lt;- tibble(\n  center_x = 0.5,\n  center_y = 0.25,\n  width = 1,\n  height = 0.5\n)\n\nx_offset &lt;- 3\ny_offset &lt;- 2\ntranslated_r &lt;- tibble(\n  center_x = r$center_x + 3,\n  center_y = r$center_y + 2,\n  width = 1,\n  height = 0.5\n)\n\ncanvas +\n  geom_tile(\n    aes(x = center_x, y = center_x,\n        height = height, width = width,\n        fill = \"Before translation\"),\n    data = r\n  ) +\n  geom_tile(\n    aes(x = center_x, y = center_x,\n        height = height, width = width,\n        fill = \"After translation\"),\n    data = translated_r\n  ) +\n  scale_fill_manual(values = c(\"#226ce3\", \"#a6c8ff\"))",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducing graphics transformations</span>"
    ]
  },
  {
    "objectID": "Chapters/01-transformations.html#scaling",
    "href": "Chapters/01-transformations.html#scaling",
    "title": "2  Introducing graphics transformations",
    "section": "2.2 Scaling",
    "text": "2.2 Scaling\nScaling is used to scale your object into a different size (i.e. to raise/shrink the size of your object). Figure 2.2 presents this process visually. We begin with the light blue and smaller triangle, and then, we scale this triangle into a bigger size, getting the strong blue triangle as a result.\n\n\n\n\n\n\nFigure 2.2: Scaling a triangle into a bigger size\n\n\n\nTo scale an object, we perform essentially the same thing that we did in translation, which was a simple math operation over the coordinates of the vertices that compose our object. But instead of adding offsets to the coordinates, we multiply each coordinate by a fixed amount/factor.\nAs an example, lets create a new triangle with the coordinates \\((0,0), (1,0), (0,2)\\). We can get a triangle that is twice bigger by multiplying each coordinate by a factor of two.\n\ntriangle &lt;- tibble(\n  x = c(0, 1, 0),\n  y = c(0, 0, 2)\n)\ntwice_triangle &lt;- tibble(\n  x = triangle$x * 2,\n  y = triangle$y * 2\n)\n\ncanvas +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"After scaling\"),\n    data= twice_triangle\n  ) +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"Before scaling\"),\n    data= triangle\n  ) +\n  scale_fill_manual(values = c(\"#226ce3\", \"#a6c8ff\"))\n\n\n\n\n\n\n\n\nIf you want to scale your object, but at the same time, keep the same center position as the original object, then, we need to perform two transformations at once: scaling and translation. We first scale the object to the size we want, and then, we translate this object to the same center position as the original object. Take this case as an example:\n\ntriangle &lt;- tibble(\n  x = c(0.25, 1.5, 0.5),\n  y = c(0.5, 0.5, 2)\n)\ntwice_triangle &lt;- tibble(\n  x = (triangle$x * 2) - (max(triangle$x) / 2),\n  y = (triangle$y * 2) - (max(triangle$y) / 2)\n)\n\ncanvas +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"After scaling\"),\n    data= twice_triangle\n  ) +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"Before scaling\"),\n    data= triangle\n  ) +\n  scale_fill_manual(values = c(\"#226ce3\", \"#a6c8ff\"))\n\n\n\n\n\n\n\n\nSo all you need to do is to multiply each coordinate by the factor you want to scale the object. If you want a bigger object, then, the factor must be a number greater than 1. But if you want a smaller object instead, then, the factor must be a number between 0 and 1. For example, if you want an object that is half the original size, you should use the factor is 0.5.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducing graphics transformations</span>"
    ]
  },
  {
    "objectID": "Chapters/01-transformations.html#rotation",
    "href": "Chapters/01-transformations.html#rotation",
    "title": "2  Introducing graphics transformations",
    "section": "2.3 Rotation",
    "text": "2.3 Rotation\nRotation is a transformation used to rotate your object to a different angle. Figure 2.3 presents this transformation visually. We start with the light blue rectangle, which is parallel to the x axis, and then, we rotate this rectangle into a new angle, getting the strong blue rectangle as the result.\n\n\n\n\n\n\nFigure 2.3: Rotating a rectangle into a different angle\n\n\n\nRotating an object is a little more complicated than the other transformations. Only because it involves some magic calculations with a little of trigonometry.\nGiven a coordinate with \\(x\\) and \\(y\\) positions in a Cartesian plane, and a angle \\(A\\) in radians to rotate this initial coordinate, the new \\(x'\\) and \\(y'\\) positions of this coordinate after the rotation can be calculated using the formulas below. \\(\\cos()\\) and \\(\\sin()\\) in these formulas are the cosine and sine trigonometric functions.\n\\[\nx' = x \\times \\cos(A) + y \\times - \\sin(A)\n\\tag{2.1}\\]\n\\[\ny' = x \\times \\sin(A) + y \\times \\cos(A)\n\\tag{2.2}\\]\n\n2.3.1 Remember to convert your angles in degrees to radians\nThis seems complicated, but, it is actually not. I mean really, you just have to follow these formulas above and you will be happy. But remember one important detail about these formulas: the trigonometric functions cos() and sin() take as input angles that are in radians.\nThis is important, because we usually think or talk about angles using the degrees measure, which goes from -360 to 360 (e.g. 90 degrees, 180 degrees, etc.). So you must convert your angle in degrees to radians, before you pass it to cos() and sin() functions.\nYou can do this by using the function deg2rad() that we introduced at Chapter 1. To make life easier, the function definition is repeated below:\n\n# A function to convert degrees to radians\ndeg2rad &lt;- function(deg){\n  return(deg * pi / 180)\n}\n\n\n\n2.3.2 A first example of rotation\nAs a first example, lets take a triangle with coordinates \\((0,0), (1,0), (0,2)\\). Lets consider we wanted to perform two different rotations over this triangle. The first, we rotate it to 30 degrees clockwise, and in the second, 90 degrees clockwise.\n\ntriangle &lt;- tibble(\n  x = c(0, 1, 0),\n  y = c(0, 0, 2)\n)\n\nangle &lt;- deg2rad(-30)\nfirst_rotated_triangle &lt;- tibble(\n  x = (triangle$x * cos(angle)) + (triangle$y * -1 * sin(angle)),\n  y = (triangle$x * sin(angle)) + (triangle$y * cos(angle))\n)\n\nangle &lt;- deg2rad(-90)\nsecond_rotated_triangle &lt;- tibble(\n  x = (triangle$x * cos(angle)) + (triangle$y * -1 * sin(angle)),\n  y = (triangle$x * sin(angle)) + (triangle$y * cos(angle))\n)\n\ncanvas +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"After second rotation\"),\n    data = second_rotated_triangle\n  ) +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"After first rotation\"),\n    data = first_rotated_triangle\n  ) +\n  geom_polygon(\n    aes(x = x, y = y, fill = \"Before rotation\"),\n    data = triangle\n  ) +\n  scale_fill_manual(values = c(\"#226ce3\", \"#0c3a85\", \"#a6c8ff\"))\n\n\n\n\n\n\n\n\nAnother very important aspect about this operation, is that the above formulas (Equation 2.1 and Equation 2.2) calculate the new coordinates of the object considering the origin point of the Cartesian plane, i.e. coordinate \\((0, 0)\\) as the “center point of the rotation”.\nIn other words, instead of rotating around the center point of the object itself, or, rotating around the leftmost point of the vertices of the object, or around whatever other point you imagine, the object is rotated around the origin point of the Cartesian plane.\nYou can imagine this rotation as if the object followed the circumference of a circle that is centered in the origin point. The radius of the circle that is formed by this circumference is the actual distance that the object is from the origin point.\nYou can see this fact more clearly by increasing the distance of your object from the origin point. In the example below, the same triangle and rotation angles as the previous example are used. But this time, the original triangle is further apart from the origin point (code is omitted for brevity reasons). To help you visualize, I have also drawn the circle that is centered at the origin point. You can see that the rotated triangles follows the circumference of that circle.\n\n\n\n\n\n\n\n\nFigure 2.4: Rotating a triangle around the origin point\n\n\n\n\n\nIn the other hand, if you do not want to have this effect in your rotation; if you do not want your objects to have a drastic movement around the plane; if you just want to rotate the object, but, at the same time, preserve it’s current position, then, you need to perform the rotation in three different stages (or steps).\nIn the first stage, you use translation to move your object to the origin point of the Cartesian plane. In the second stage, you apply the rotation to the object after the previous translation, that is, you use Equation 2.1 and Equation 2.2 to calculate the new x and y positions after the rotation. Then, in the final and third stage, you use translation again to move your object back to the original position it had in the Cartesian plane.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducing graphics transformations</span>"
    ]
  },
  {
    "objectID": "Chapters/01-transformations.html#how-to-rotate-lines",
    "href": "Chapters/01-transformations.html#how-to-rotate-lines",
    "title": "2  Introducing graphics transformations",
    "section": "2.4 How to rotate lines",
    "text": "2.4 How to rotate lines\nTherefore, you can use Equation 2.1 and Equation 2.2 to calculate the new coordinates of a polygon that was rotated by a certain angle. However, rotating lines is kind of a special case, because it is a bit trickier to rotate lines than most polygons.\n\n2.4.1 Why is it trickier?\nI mean, you can still use Equation 2.1 and Equation 2.2, as we were using before, to calculate the new coordinates of a line after you rotated it by a certain angle. You will definitely get an output that is mathematically right. But this output will probably look wrong, and will likely not be what you really want.\nGenerally speaking, when you are rotating a line, there are two basic scenarios, which are exposed in Figure 2.5. You are normally trying to achieve one of these two scenarios. In the first scenario, you lock one of the endpoints of the line, then, you rotate the rest of the line around this locked point. Is like you were increasing (or decreasing) the angle in one edge of a triangle. In contrast, in the second scenario, we are rotating the entire line around it’s center. Is like when you are playing that “spin the bottle” game in teenagers parties. You are trying to rotate the bottle, but at the same time, maintaining it’s center point intact.\n\n\n\n\n\n\nFigure 2.5: Scenarios when you are trying to rotate a line\n\n\n\nHowever, when you use directly Equation 2.1 and Equation 2.2 as we were using before, you get the effect that we described at Figure 2.4. Thus, you rotate the line around the origin point of the Cartesian plane, instead of rotating it around it’s center point, or around one of it’s endpoint.\nSo when you use Equation 2.1 and Equation 2.2 directly, instead of getting scenario 1 or scenario 2 from Figure 2.5, you would get a visual result that would looks something like this:\n\n\n\n\n\n\nFigure 2.6: Rotating a line around the origin point\n\n\n\n\n\n2.4.2 How to solve it?\nBut you already know the solution to this problem, because we already talked about it , at the end of Section 2.3.2. If you want to perform a static rotation (i.e. a rotation that just rotate the object and does not move the object around the Cartesian plane), you need to perform the rotation in three stages:\n\ntranslation to the origin point.\nrotate the object.\ntranslation back to the original position.\n\nThe essence is the same. So, the first thing that we need to do is to move the line to the origin point in the plane. Now, the way you perform this first step will determine which one of the two scenarios we described at Figure 2.5 you will get.\nAs the example in this section, let’s use the line described in the plot below. Which have the coordinates \\((1.5, 0.6)\\) and \\((3.7, 2.7)\\):\n\nline &lt;- tibble(\n  x = c(1.5, 3.7),\n  y = c(0.6, 2.7)\n)\n\ncanvas +\n  geom_line(aes(x,y), data = line)\n\n\n\n\n\n\n\n\nIf you want to apply a rotation over this line that looks like scenario 1, then, you should first choose which one of the two endpoints of the line will be your “locked point”. After you choose the point, you apply a translation over the line, using the x and y positions of the “locked point” as the x and y offsets of the translation.\nIn this example, let’s suppose we wanted the coordinate \\((1.5, 0.6)\\) to be our locked point, and also, that we wanted to apply a 35 degrees counter-clockwise rotation to the line. To achieve scenario 1, we would do something like this:\n\nlibrary(dplyr)\nA &lt;- deg2rad(35)\nrotated_line &lt;- line |&gt;\n  mutate(x = x - 1.5, y = y - 0.6) |&gt;\n  mutate(\n    x = (x * cos(A)) + (y * -sin(A)),\n    y = (x * sin(A)) + (y * cos(A))\n  ) |&gt;\n  mutate(x = x + 1.5, y = y + 0.6)\n\ncanvas +\n  geom_line(\n    aes(x, y, color = \"Original line\"),\n    data = line\n  ) +\n  geom_line(\n    aes(x, y, color = \"Rotated line\"),\n    data = rotated_line\n  )\n\n\n\n\n\n\n\n\nNow, if you want to achieve the scenario 2 in Figure 2.5 instead, then, all you need to do is to change the x and y offsets when translating the object. Because in this situation, you want to move the center of the line to the origin point, and not one of the endpoints of the line.\nFirst, we calculate where the coordinates of the line’s center. Once we have that, we use the x and y positions of this center point as the x and y offsets in the translations. As a result, we get a rotation that looks like scenario 2:\n\nxd &lt;- (max(line$x) + min(line$x)) / 2\nyd &lt;- (max(line$y) + min(line$y)) / 2\n\nrotated_line &lt;- line |&gt;\n  mutate(x = x - xd, y = y - yd) |&gt;\n  mutate(\n    x = (x * cos(A)) + (y * -sin(A)),\n    y = (x * sin(A)) + (y * cos(A))\n  ) |&gt;\n  mutate(x = x + xd, y = y + yd)\n\ncanvas +\n  geom_line(\n    aes(x, y, color = \"Original line\"),\n    data = line\n  ) +\n  geom_line(\n    aes(x, y, color = \"Rotated line\"),\n    data = rotated_line\n  )\n\n\n\n\n\n\n\n\n\n\n2.4.3 How to rotate a line and keep the same length\nMaybe, you have noticed in the previous two examples, that the rotated line got a little smaller in length compared to the original line. This happened because of the way Equation 2.1 and Equation 2.2 works.\nBut what if you do not want to have this effect? What you should do to avoid a reduction/increase in the length of the line. If that is your case, then, the best solution is to change completely the strategy we are using to rotate the line.\nThis new strategy, involves the use of another pair of equations to rotate the line. Actually, you already saw this pair of equations here in this book, which are Equation 1.3 and Equation 1.4 that were presented in Chapter 1.\nWe use Equation 1.3 and Equation 1.4 to calculate the coordinate of any point in the circumference of a circle. But we can also use these equations to calculate the coordinates of a line rotated to a specific angle.\nIn this context, we want to use the simplified versions of Equation 1.3 and Equation 1.4, which uses a circle that is centered at the origin point of the Cartesian plane. Besides that, in this context, the variable \\(r\\) that is present both at Equation 1.3 and Equation 1.4 becomes the length of the line we want to calculate.\nHaving that in mind, given that \\(x'\\) and \\(y'\\) are the x and y positions of the line, that \\(l\\) is the line’s length, and that \\(A\\) is the angle of the line, we get the following formulas:\n\\[\nx' = l \\times \\cos(A)\n\\tag{2.3}\\]\n\\[\ny' = l \\times \\sin(A)\n\\tag{2.4}\\]\nBy using these equations, we can calculate the coordinates of line with length \\(l\\), that is in a specific angle \\(A\\). But in order to use these two equations, we first need to calculate:\n\nthe length of our line.\nthe current angle of our line.\n\n\n\n2.4.4 Calculating the length of the line\nLet’s start by calculating the length of our line. Remember that, we are using the line with coordinates \\((1.5, 0.6)\\) and \\((3.7, 2.7)\\) as our main example here.\nGiven that \\(l\\) is the line length that we want to calculate, and that \\(x_1\\) and \\(y_1\\) are the x and y positions of any of the endpoints of the line, and that \\(x_2\\) and \\(y_2\\) are the x and y positions of the other endpoint of the line, you can calculate the line length by following the formula below. This formula is also known as the “distance formula”.\n\\[\nl = \\sqrt{[(x_2 - x_1)^2 + (y_2 - y_1)^2]}\n\\tag{2.5}\\]\nIs important to emphasize, that you can choose whatever endpoint you want for \\(x_1\\) and \\(y_1\\). It can be the leftmost point of the line, or the rightmost. Once you choose the endpoint for \\(x_1\\) and \\(y_1\\), the endpoint for \\(x_2\\) and \\(y_2\\) automatically becomes the other endpoint of the line.\nIn our example, lets use \\((1.5, 0.6)\\) as our endpoint 1, and \\((3.7, 2.7)\\) as our endpoint 2. With that, the line length is:\n\\[\nl = \\sqrt{(3.7 - 1.5)^2 + (2.7 - 0.6)^2}=3.041381\n\\]\nWe can obviously encapsulate Equation 2.5 into a nice R function that we can reuse whenever we want. If we do that, we get a function similar to line_length() below. You can see that we get the same result as above:\n\n# Function to calculate the length of a line\nline_length &lt;- function(x1, y1, x2, y2){\n  s1 &lt;- (x2 - x1)^2\n  s2 &lt;- (y2 - y1)^2\n  return(sqrt(s1 + s2))\n}\n\nl &lt;- line_length(1.5, 0.6, 3.7, 2.7)\nl\n\n[1] 3.041381\n\n\n\n\n2.4.5 Calculating the current angle of the line\nYou can easily calculate the current angle of a line by using the arc-tangent function with two arguments, also known as the atan2() function from R.\nHowever, before you use this function, you have to move/translate your line to the origin point of the Cartesian plane. This way, you will get a single \\((x, y)\\) coordinate that is capable of identifying the line, because the other coordinate will always be the origin point - \\((0, 0)\\).\nWe can see in the result below, that the new coordinate of the endpoint of the line after we translated it to the origin point is \\((2.2, 2.1)\\).\n\ntranslated_line &lt;- line |&gt;\n  mutate(\n    x = x - min(x),\n    y = y - min(y)\n  )\n\ntranslated_line\n\n# A tibble: 2 × 2\n      x     y\n  &lt;dbl&gt; &lt;dbl&gt;\n1   0     0  \n2   2.2   2.1\n\n\nSo this is the coordinate we need to use in the atan2() function. For some reason, in atan2() you need to provide the y position first, and the x position second. A little and odd detail about this function.\nAnyway, the code below demonstrates that the current angle of our line is approximately 43.6 degrees.\n\nA &lt;- atan2(2.1, 2.2)\nprint(glue::glue(\"In radians: {A}\"))\n\nIn radians: 0.762146540586985\n\nD &lt;- rad2deg(A)\nprint(glue::glue(\"In degrees: {D}\"))\n\nIn degrees: 43.6677801461304\n\n\nIf you prefer, there is also another method to to calculate the angle of a line. But this other method involves a weird formula from geometry. This formula is used to calculate the angle between two vectors in the Euclidean space.\nTo use this formula you must provide the coordinates of two vectors. Is worth noting that each vector is identified by a single \\((x, y)\\) coordinate. Because both vectors starts at the origin point (\\((0, 0)\\)) and goes to \\((x, y)\\) coordinate, which is the x and y positions that mark the endpoint of the vector.\nGiven that \\(x_1\\) and \\(y_1\\) are the x and y positions of vector 1, and that \\(x_2\\) and \\(y_2\\) are the x and y positions of the other vector, you can calculate the angle (in radians) between these two vectors by following the formula below. In this formula, \\(\\arccos\\) represents the arc-cosine function, which is the inverse function for cosine.\n\\[\nA = \\arccos{\\frac{\n    (x_1 \\times x_2) + (y_1 \\times y_2)\n  }\n  {\n    \\sqrt{x_1^2 + y_1^2} \\times \\sqrt{x_2^2 + y_2^2}\n  }}\n\\tag{2.6}\\]\nIs a good idea to incorporate this crazy formula into a nice and simple R function, to make our life much easier. If we do that, we get the line_angle() function below as result:\n\nline_angle &lt;- function(x1, y1, x2, y2){\n  h &lt;- (x1 * x2) + (y1 * y2)\n  b &lt;- sqrt((x1 ^ 2) + (y1 ^ 2)) *\n    sqrt((x2 ^ 2) + (y2 ^ 2))\n  \n  return(acos(h/b))\n}\n\nThe \\(x_2\\) and \\(y_2\\) coordinates should represent the x axis. So, you can set these variables to \\(x_2 = 4\\) and \\(y_2 = 0\\) for example. In the other hand, \\(x_2\\) and \\(y_2\\) coordinates are the same as we used in atan2(), that is, \\(x_1 = 2.2\\) and \\(y_1 = 2.1\\).\nYou can see below that, by using the line_angle() function we got the exact same results as the atan2() function.\n\nA &lt;- line_angle(2.2, 2.1, 4, 0)\nprint(glue::glue(\"In radians: {A}\"))\n\nIn radians: 0.762146540586985\n\nD &lt;- rad2deg(A)\nprint(glue::glue(\"In degrees: {D}\"))\n\nIn degrees: 43.6677801461304\n\n\n\n\n2.4.6 Rotating the line\nNow that we have the two essential information we needed: 1) the length of the line; 2) the current angle of the line. We can proceed and effectively rotate the line, while, at the same time, maintaining the length of the line intact.\n\n# Current angle\nA &lt;- atan2(2.1, 2.2)\n# Current angle + the angle we want to rotate\nA &lt;- A + deg2rad(35)\n# The length of the line\nl &lt;- line_length(1.5, 0.6, 3.7, 2.7)\nrotated_line &lt;- line |&gt;\n  mutate(\n    x = c(0, l * cos(A)),\n    y = c(0, l * sin(A))\n  ) |&gt;\n  mutate(\n    x = x + 1.5,\n    y = y + 0.6\n  )\n\ncanvas +\n  geom_path(\n    aes(x, y, color = \"Rotated line\"),\n    data = rotated_line\n  ) +\n  geom_path(\n    aes(x, y, color = \"Original line\"),\n    data = line\n  )\n\n\n\n\n\n\n\n\nRemember, the above example uses the values \\(1.5\\) and \\(0.6\\) as the x and y offsets in the translations to produce a rotation similar to scenario 1 presented at Figure 2.5.\nIf you want a rotation similar to scenario 2 instead, then, you have to change the x and y offsets in the translation to move your rotated line back to the center point of your original line. In other words, if \\(l1\\) is your original line , and \\(l2\\) is the rotated version of the line, you have to choose x and y offsets in the translation that will lined up the center point of \\(l2\\) with the center point of \\(l1\\).\nIf we wanted to replicate the scenario 2 for the above example, we would need first, to calculate the coordinates of the center point of both \\(l1\\) and \\(l2\\), then, calculate the difference between the coordinates of these two center points, then, use this difference as the x and y offsets in the translation.\nTake the case below as an example:\n\nrotated_line &lt;- line |&gt;\n  mutate(\n    x = c(0, l * cos(A)),\n    y = c(0, l * sin(A))\n  )\n\nrotated_centerx &lt;- (\n  max(rotated_line$x)\n  + min(rotated_line$x)\n) / 2\nrotated_centery &lt;- (\n  max(rotated_line$y)\n  + min(rotated_line$y)\n) / 2\n\noriginal_centerx &lt;- (\n  max(line$x) + min(line$x)\n) / 2\noriginal_centery &lt;- (\n  max(line$y) + min(line$y)\n) / 2\n\nxd &lt;- original_centerx - rotated_centerx\nyd &lt;- original_centery - rotated_centery\nrotated_line &lt;- rotated_line |&gt;\n  mutate(\n    x = x + xd,\n    y = y + yd\n  )\n\ncanvas +\n  geom_path(\n    aes(x, y, color = \"Rotated line\"),\n    data = rotated_line\n  ) +\n  geom_path(\n    aes(x, y, color = \"Original line\"),\n    data = line\n  )",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducing graphics transformations</span>"
    ]
  },
  {
    "objectID": "Chapters/02-random.html#about-random-seeds-and-random-number-generation",
    "href": "Chapters/02-random.html#about-random-seeds-and-random-number-generation",
    "title": "3  Producing chaos and randomness",
    "section": "3.1 About random seeds and random number generation",
    "text": "3.1 About random seeds and random number generation\nComputers can not generate “true random numbers”. Instead, they use an “initial state” as the basis for generating the random values. That is why we usually say that computers can generate “pseudo-random numbers”.\nThey are “pseudo” in the sense that they are not truly random, because they are based in a state that can be reproduced, if we want to. But they are “random” still because they look random enough for us, mere humans, and they do have some component of randomness that are intrinsic to them.\nBut what is this “initial state”, from which the random numbers are generated? This “initial state” is usually represented as a single integer, and it is called as the “seed for the random number generation”, or simply, a “random seed”. So, to generate random numbers in R, we use an integer as the “seed” to represent the initial state for the random number generation.\nIn the example below, we can see that every time I run runif(), I get a different answer as result, or a different set of random values:\n\nrunif(3)\n\n[1] 0.6302539 0.2527524 0.6907540\n\nrunif(3)\n\n[1] 0.1390849 0.6943531 0.9863443\n\n\nThis happens because the “initial state” is different in each call to runif(). Every time I run runif(), R automatically and randomly selects a seed for you. That is why the results in the example above are different between each call to runif(). Because the seeds used in each call are different.\nIf we use the same “seed” as the initial state, we can produce the exact same set of random numbers. That is, if we want to have reproducibility in this process of number generation, we need to use the same random seed that was used before.\nYou can set the integer to be used as the random seed, by using the set.seed() function. In the example below, I am setting the random seed to 40. Because of that, I get the exact same set of random values in each call to runif().\n\nset.seed(40)\nrunif(3)\n\n[1] 0.6835820 0.8729038 0.6901173\n\nset.seed(40)\nrunif(3)\n\n[1] 0.6835820 0.8729038 0.6901173\n\n\nThis is very important! If you do not set your random seed, then, you will never be able to reproduce the same set of random values, and, as consequence, you will never be capable of reproducing the same art again, or the same output in your generative art.\nLet me repeat this. You should always explicitly set the random seed you are using in your process. Because if do not, then, you are facing the risk of producing a very cool output in your code by completely accident, and you loose the chance to save this output in time, or to reproduce it later in the day, or to improve it by adding more adjusts in configuration, colors, brightness, and positions.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Producing chaos and randomness</span>"
    ]
  },
  {
    "objectID": "Chapters/02-random.html#sec-random-styles",
    "href": "Chapters/02-random.html#sec-random-styles",
    "title": "3  Producing chaos and randomness",
    "section": "3.2 Different types of generators",
    "text": "3.2 Different types of generators\nThere are different types of generators available in R. Each generator produces a sequence of random values following a specific rule or target, and as a consequence of that, each one produces a different type of randomness.\nIn base R, there are at least three generators that you must known for generative art:\n\nrunif() produces random values that follow a uniform distribution;\nrnorm() produces random values that follow a normal distribution;\nsample() produces a random sample from a known set of values;\n\nBoth runif() and rnorm() functions can be used to generate a sequence of random numbers, while the function sample() is used when you are trying to generate a random sample from a known set of values.\nThere are other generators available in R that will be very useful for you in generative art, specially trough the ambient R package1, which is a R interface to the FastNoise C++ library.\nThis ambient package offers two other generators that will be discussed here, which are:\n\nambient::noise_perlin(): produces random values using the Perlin Noise algorithm.\nambient::noise_simplex(): produces random values using the Simplex Noise algorithm.\n\nBut these two generators from the ambient R package produces random values exclusively for two to three dimensions. Because of that, they will be discussed in details only at Section 3.4.\n\n3.2.1 Uniform distribution with runif()\nThe runif() function generates a sequence of random values by following an uniform distribution. It basically means that no specific number is favored during the generation process. Each number have an equal amount of chance to be selected in the output.\nYou could say that runif() produces an output that truly looks “random” in all aspects. Because nothing is unbalanced, nothing is favored in detriment of the other, and therefore, you cannot see any clear pattern in the result, everything just looks… completely random.\nBy using a histogram, we can see this very balanced aspect of runif(). In the output below, we can see that each range of numbers described in the histogram appears in the output by an almost equal amount. That is why the distribution is called “uniform”.\n\nset.seed(532)\nv &lt;- runif(1000)\nhist(v)\n\n\n\n\n\n\n\n\nThe function runif() have three arguments: 1) n - the number of random values to be generated; 2) min - the minimum value that can be generated; 3) max - the minimum value that can be generated.\nYou can use the min and max arguments to specify the range of values that will be generated. If you use for example, runif(10, min = 0, max = 50), it means that R will generate 10 random values, ranging from 0 to 50.\n\nrunif(10, min = 0, max = 50)\n\n [1] 42.58383 38.58029 30.60287 25.59512 20.91538 36.19737 30.04260 24.12355\n [9] 19.17031 19.36764\n\n\nBy default, the min and max arguments are configured to 0 and 1. As a consequence, instead of explicitly setting these arguments, to achieve a certain range of values, you can also use a factor to scale the random values generated to the scale you want to. This means that, the code runif(10) * 50 is essentially the same thing that setting min and max to 0 and 50.\n\n\n3.2.2 Normal distribution with rnorm()\nWhile runif() follows a uniform distribution, the rnorm() function generates a sequence of random values by following a normal distribution instead.\nThis is a big difference, because it means that numbers that are closer to the mean of the distribution will be selected more often than others. This makes the output from rnorm() not so much random as it is in runif(), because now, we have a clear pattern (more numbers closer to the mean) present in the output.\nWe can use a histogram again to see this pattern more clearly. You can see in the output below that, numbers that are closer to zero (which is the mean of the distribution) appears more often than numbers that are further apart, in the extremities of the distribution.\n\nset.seed(532)\nv &lt;- rnorm(1000)\nhist(v)\n\n\n\n\n\n\n\n\nThe function rnorm() have three arguments: 1) n - the number of random values to be generated; 2) mean - the mean value of the distribution; 3) sd - the standard deviation of the value.\n\nrnorm(10, mean = 50, sd = 10)\n\n [1] 49.21595 47.02894 38.14195 48.00484 59.31028 49.19061 53.44236 63.60016\n [9] 44.24109 41.01438\n\n\nYou can use the mean argument to concentrate the random values around a specific value of your preference. For example, if mean = 50, then, the majority of random values generated will be close to 50.\nWith the sd argument you control how much the values distance from the mean value of the distribution. If sd is very high, then the distribution will be more spread, meaning that the values will be, in general, more distant from the mean. If sd is low, then, the inverse will happen.\n\n\n3.2.3 Taking a random sample with sample()\nWhen you have a known and finite set of values, and you want to randomly distribute them across your generative art, the function sample() is the perfect candidate to help you in this task.\nThe function sample() have three arguments: 1) x - and object that contains the set of values from which you want to extract the sample; 2) size - the size of the sample, i.e. how many elements will have in the output sample; 3) replace - the sample should be performed with replacement?\nThe replace argument determines if each value in the object x can be selected more than once in the output. In others words, if a specific value is selected in the sample, can this value be selected again over the next elements of the sample? For the majority of cases, you will probably answer “yes” to this question. So you normally set this argument to TRUE. But this might not be your case, so you would have to set this argument to FALSE.\nI personally use sample() a lot to distribute my color pallete across the elements of my image. Take the code below as an example, I have 100 points in my plot, and I want to randomly select a color from the pallete object to each point. I can easily do that with sample():\n\nlibrary(ggplot2)\n\nWarning: package 'ggplot2' was built under R version 4.3.2\n\nlibrary(tibble)\npallete &lt;- c(\n  \"#8ecae6\",\n  \"#219ebc\",\n  \"#023047\",\n  \"#ffb703\",\n  \"#fb8500\"\n)\n\nset.seed(50)\ndf &lt;- tibble(\n  x = runif(100),\n  y = runif(100)\n)\ndf$color &lt;- sample(\n  pallete, size = 100, replace = TRUE\n)\n\nggplot(df) +\n  geom_point(\n    aes(x, y, color = color),\n    size = 3\n  ) +\n  scale_color_identity()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Producing chaos and randomness</span>"
    ]
  },
  {
    "objectID": "Chapters/02-random.html#sec-two-dimensions-random",
    "href": "Chapters/02-random.html#sec-two-dimensions-random",
    "title": "3  Producing chaos and randomness",
    "section": "3.3 Generating random values across two dimensions",
    "text": "3.3 Generating random values across two dimensions\nOn this section, we will discuss how to generate random values in two dimensions (x and y axis) of the Cartesian plane. Previously, we were generating random values in only one dimension, because we had a single sequence of random values at hand. But you are not limited to that!\nEven though runif() and rnorm() are functions that generates a single sequence of random values, in theory, there is nothing stopping you from spreading this sequence of random values across any dimensions you want in the Cartesian plane.\nIn other words, there is hacky way of producing two dimensional randomness from a single sequence of random values. The basic idea is to generate a single sequence of random values, that is big enough to fill a matrix of dimensions \\((x, y)\\). Then you simply spread the values of this sequence through the elements of this matrix. Because this matrix have two dimensions (x and y), it behaves as the two dimensions in the Cartesian plane.\nFor example, let’s suppose you are building a generative art inside an image with 100x100 area. That is, an image with 100 pixels of width and 100 pixels of height. If you want to add some randomness to all pixels in this image, then, you need to generate \\(100^2\\) random values, and spread these values across each coordinate in this 100x100 area.\nHaving that in mind, you could produce a sequence of \\(100^2\\) random values, and then, store these values in a matrix of 100 rows and 100 columns. This way, each element in the matrix represents a specific spot/pixel in your image.\n\nv &lt;- runif(100^2)\nm &lt;- matrix(v, ncol = 100, nrow = 100)\n\nYou could also, store this sequence of random values inside a tibble. You just add two new columns in this tibble to store the x and y coordinates for each random value in the sequence. This is also a valid strategy to map each random value to a specific spot/pixel in your image.\n\ndf &lt;- tibble(\n  x = rep(seq_len(100), each = 100),\n  y = rep(seq_len(100), times = 100),\n  random_value = runif(100^2)\n)\n\nIn the example below, we are using runif() to generate random values in two dimensions. After that, I plot these random values as points colored with a gradient of colors. Each point represents a specific point/coordinate in the Cartesian plane, and it’s color represent the random value that was mapped to that particular position in the plane.\nThis visualization is a great way to visualize the “true randomness” of runif(). Because we can not see any clear pattern in the colors of the points, they just looks like a complete mess of colors.\n\nlibrary(ggplot2)\nbuild_df &lt;- function(random_values, n){\n  tibble(\n    x = rep(seq_len(n), each = n),\n    y = rep(seq_len(n), times = n),\n    value = random_values |&gt; as.vector()\n  )\n}\n\nn &lt;- 100\nset.seed(40)\nrandom &lt;- matrix(runif(n ^ 2), n, n)\nd &lt;- build_df(random, n)\n\nggplot(d) +\n  geom_point(\n    aes(x = x, y = y, color = value),\n    size = 3\n  ) +\n  theme_void()\n\n\n\n\n\n\n\n\nWhen we use rnorm() instead, it still produces a pretty random result. However, we can see that the colors are more flat, they seem less random compared to runif(). If you remember of Section 3.2.2, what is happening is that rnorm() tends to select values that are closer to the mean of the distribution, which is zero in this case.\nThat is why the colors in the plot looks more flat. The colors in the image below seen more flat, because the majority of the values sorted by rnorm() are values that are very close to zero.\n\nset.seed(40)\nrandom &lt;- matrix(rnorm(n ^ 2), n, n)\nd &lt;- build_df(random, n)\n\nggplot(d) +\n  geom_point(\n    aes(x = x, y = y, color = value),\n    size = 3\n  ) +\n  theme_void()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Producing chaos and randomness</span>"
    ]
  },
  {
    "objectID": "Chapters/02-random.html#sec-perlin-noise",
    "href": "Chapters/02-random.html#sec-perlin-noise",
    "title": "3  Producing chaos and randomness",
    "section": "3.4 Introducing Perlin noise",
    "text": "3.4 Introducing Perlin noise\nPerlin noise is a type of gradient noise developed by Ken Perlin in 1983 (Wikipedia 2024). I think there are two ways of describing what Perlin noise is. One approach is to answer “why it was developed?”. And the other approach is to explain what the output of the algorithm looks like.\nIn essence, the Perlin noise algorithm was developed by Ken, after his experience working at the Disney’s film called “Tron”2. The main idea behind it, was to develop an algorithm that produced more natural appearing textures on the computer screen. In other words, Perlin noise was developed to improve the quality of textures used in computer graphics.\nThis algorithm produces as output a sequence of random values, as any other random number generator we have seen so far. But the key feature of this algorithm, is that each random value in the sequence is very close (or “similar”) to it’s neighbors.\nFor example, if you produce a sequence of, let’s say, 100 random values with Perlin noise, the 12th value in this sequence will be a value that is very close to the values in the 10th and 13th position in the sequence. This logic repeats to all values in the sequence.\nThe main consequence of this characteristic, is that you get a very smooth transition between each random value in the sequence. These values have a less erratic, or drastic behavior, compared to the values produced by others generators, such as runif().\nWe can visualize this pattern of the algorithm by using the same visualization we were using in the previous section. You can see in the output below that, the color variation is very smooth compared to the output of runif() or rnorm(). In fact, the color variation is so smooth that you can actually see patterns or shapes in the output.\nTo generate random values with Perlin noise in R, we use the noise_perlin() function from the ambient R package. The first and main argument of this function, is the dimensions of the matrix of random values you want to produce. If you want, let’s say, a matrix with 50 columns and 50 rows (that is \\(50 \\times 50 = 2500\\) random values), then, you give the vector c(50, 50) as input to this function. In the example below, we are creating \\(100 \\times 100 = 10000\\) random values.\n\nlibrary(ambient)\n\nWarning: package 'ambient' was built under R version 4.3.2\n\nn &lt;- 100\nset.seed(40)\nrandom &lt;- noise_perlin(c(n, n))\nd &lt;- build_df(random, n)\n\nggplot(d) +\n  geom_point(\n    aes(x = x, y = y, color = value),\n    size = 3\n  ) +\n  theme_void()\n\n\n\n\n\n\n\n\nThe Perlin noise is one of the most used algorithms in the computer graphics industry. It is used everywhere, and it is massively used in generative art as well.\nThis algorithm is so powerful that it’s author, Ken Perlin, won one of the highest prizes in computer science for creating it.\nBut despite it’s popularity, the original Perlin noise algorithm have some important limitations regarding the features of the noise produced, and also, the big amount of computational resources required to compute the noises at larger scales.\nThat is why, Ken Perlin developed a new algorithm, called the Simplex noise. Simplex noise is an algorithm that produces similar results as the Perlin noise. But it is much faster to compute at larger scales, and the noise values produced by it also have some different features.\nThe Simplex noise algorithm normally produces “stronger” results compared to the original Perlin noise. In other words, the random values produced by the algorithm vary more rapidly.\nYou can see this fact in the output below. Because you have more patterns in the result image, or, a more detailed image in general. You can also describe it as: the transitions between blue and black are faster (or, less smooth), compared to the output of Perlin noise.\nWe use again the ambient R package to generate Simplex noise values. But this time, we use the noise_simplex() function instead, that uses the Simplex noise algorithm. The idea is exactly the same as it was in noise_perlin(). In the first and main argument of the function, you give the dimensions of the output matrix you want, as a vector of 2 elements.\n\nset.seed(40)\nrandom &lt;- noise_simplex(c(n, n))\nd &lt;- build_df(random, n)\n\nggplot(d) +\n  geom_point(\n    aes(x = x, y = y, color = value),\n    size = 3\n  ) +\n  theme_void()\n\n\n\n\n\n\n\n\n\n\n\n\nWikipedia, The Free Encyclopedia. 2024. “Perlin Noise.” https://en.wikipedia.org/wiki/Perlin_noise.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Producing chaos and randomness</span>"
    ]
  },
  {
    "objectID": "Chapters/02-random.html#footnotes",
    "href": "Chapters/02-random.html#footnotes",
    "title": "3  Producing chaos and randomness",
    "section": "",
    "text": "https://ambient.data-imaginist.com/index.html.↩︎\nhttps://en.wikipedia.org/wiki/Tron.↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Producing chaos and randomness</span>"
    ]
  },
  {
    "objectID": "Chapters/03-flow-fields.html#building-a-grid-of-angles",
    "href": "Chapters/03-flow-fields.html#building-a-grid-of-angles",
    "title": "4  Introducing Flow Fields",
    "section": "4.1 Building a grid of angles",
    "text": "4.1 Building a grid of angles\nLet’s start with “how to create a grid of angles?”. Since we are talking about a 2D grid, with x and y coordinates, we want to store this grid either as a 2D matrix, or, as a tibble with x and y columns. To do that, you could use the exact same techniques as we used at Section 3.3, to build a 2D matrix or a tibble to store two dimensional random values.\nIn essence, if you prefer to build the 2D matrix, you could simply pass the vector with all the angles values in the grid to the matrix(), and specifying the number of columns and rows that you want to use.\nIn the other hand, if you prefer the tibble instead, we used the rep() function in conjunction with seq_len() to build the x and y coordinates columns in the tibble. The function build_grid_df() below summarizes this technique:\n\nlibrary(tibble)\nbuild_grid_df &lt;- function(angles, n) {\n  tibble(\n    x = rep(seq_len(n), each = n),\n    y = rep(seq_len(n), times = n),\n    value = angles |&gt; as.vector()\n  )\n}\n\n\n4.1.1 Building a fixed angle grid\nLet’s start by building a grid with a fixed angle. This means that all coordinates in the grid will have the exact same angle value. So the angle is “fixed”, or “constant” across the grid.\nTo build such a grid, simply use a constant value across your matrix or tibble. In the example below, we are creating a 100x100 grid filled with the angle \\(\\pi/4\\).\n\nn &lt;- 100\nfixed_angle &lt;- pi / 4\ngrid &lt;- build_grid_df(fixed_angle, n)\ngrid\n\n# A tibble: 10,000 × 3\n       x     y value\n   &lt;int&gt; &lt;int&gt; &lt;dbl&gt;\n 1     1     1 0.785\n 2     1     2 0.785\n 3     1     3 0.785\n 4     1     4 0.785\n 5     1     5 0.785\n 6     1     6 0.785\n 7     1     7 0.785\n 8     1     8 0.785\n 9     1     9 0.785\n10     1    10 0.785\n# ℹ 9,990 more rows\n\n\nBut how can we can visualize this grid of angles? Well… we can draw \\(100^2\\) small lines with this same particular angle, and then, we spread all of these lines across the grid, using a translation operation as we presented at Section 2.1.\nSo, all we have to do, is to draw \\(100^2\\) lines that are identical (same length, same angle), and then, we apply a translation to move each individual line to a particular point in the grid. Like that:\n\nlibrary(tidyverse)\n\nvisualize_grid &lt;- function(grid, n){\n  # Calculate the n^2 lines\n  grid &lt;- grid %&gt;% \n    mutate(\n      line_id = seq_len(nrow(grid)),\n      x_line = map(value, \\(x) c(0, cos(x))),\n      y_line = map(value, \\(y) c(0, sin(y))),\n    ) %&gt;% \n    unnest(c(x_line, y_line))\n  \n  # Spread the lines across the grid\n  grid &lt;- grid %&gt;% \n    mutate(\n      x = x + x_line,\n      y = y + y_line\n    )\n  \n  # Plot these lines\n  ggplot(grid) +\n    geom_path(aes(x, y, group = line_id)) +\n    coord_cartesian(\n      xlim = c(0,n), ylim = c(0,n)\n    ) +\n    theme_void()\n}\n\n\nvisualize_grid(grid, n)\n\n\n\n\n\n\n\n\nYou can see in the output above, that all lines are in the same angle. Because the angle value is constant across the grid. But a flow field with constant angle values is kind of useless. So let’s level up this game by introducing some randomness.\n\n\n4.1.2 Building a random angle grid\nNow, we can add a little bit of randomness to this field, by using random angle values. First, we generate \\(100^2\\) random values with runif().\nHowever, we need to scale these random values. By default, runif() generates random values that are between 0 and 1. You can use these values as percentages (from 0% to 100%) to transport them into a different scale.\nThe radians scale goes from \\(-2\\pi\\) to \\(2\\pi\\), when both clockwise, and counter-clockwise movements are considered. But for this example, let’s consider solely counter-clockwise movements, which limits the scale to positive values (from zero to \\(2\\pi\\)). So we can multiply the random values produced by runif() with \\(2\\pi\\), to transport these random values into the radians scale.\nAfter that, we spread these random angle values into a grid with the build_grid_df() function we created before:\n\nset.seed(50)\nangles &lt;- runif(n ^ 2) * 2 * pi\ngrid &lt;- build_grid_df(angles, n)\n\nNow that we have the grid of angles, all we have to do is to visualize it, with the visualize_grid() function that we created in the previous section. And yeah… this field is a mess, because we now have \\(100^2\\) lines that are in completely random angles:\n\nvisualize_grid(grid, n)\n\n\n\n\n\n\n\n\nIn other words, this field is simply too much random! We do need to use random values to create an actual flow field. But these random values need to have some minimal level of resemblance with each other.\nBut despite this being a very messy field, you may find a new utility for it. Everything depends of your creativity. For example, this field as is, might be an interesting candidate to be a soft pattern in the background of your art. In other words, this flow field might not be the main character in your art, but he might be an element to support the rest of your idea.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introducing Flow Fields</span>"
    ]
  },
  {
    "objectID": "Chapters/03-flow-fields.html#building-an-actual-flow-field-with-perlin-noise",
    "href": "Chapters/03-flow-fields.html#building-an-actual-flow-field-with-perlin-noise",
    "title": "4  Introducing Flow Fields",
    "section": "4.2 Building an actual flow field with Perlin Noise",
    "text": "4.2 Building an actual flow field with Perlin Noise\nAt Section 4.1.2, we produced a field that was just too much random. We could hardly call that a “flow field”, because there was nothing fluid about it. The lines across the grid had no connection with each other, like a machine gun that was desperately shooting to all directions at the same time.\nSo now, let’s produce an actual flow field. A field of angles that actually makes sense. And for that, we are going to use the Perlin Noise algorithm (that was presented at Section 3.4) in our favor.\nFirst thing we need to do, is to generate the grid of random values. With Perlin Noise, that is extremely easy to make, because we can easily get a 2D matrix of random values with the noise_perlin() function from the ambient R package, as we described at Section 3.4.\nBut this time, we need, once again, to scale these random values produced by Perlin Noise, so that they represent actual angle values, using the radians scale. To that, we simply multiply these values by \\(2\\pi\\), in the same way as we did at Section 4.1.2.\n\nlibrary(ambient)\n\nWarning: package 'ambient' was built under R version 4.3.2\n\nset.seed(50)\nangles &lt;- noise_perlin(c(n, n)) * 2 * pi\ngrid &lt;- build_grid_df(angles, n)\ngrid\n\n# A tibble: 10,000 × 3\n       x     y  value\n   &lt;int&gt; &lt;int&gt;  &lt;dbl&gt;\n 1     1     1 0     \n 2     1     2 0.0366\n 3     1     3 0.0769\n 4     1     4 0.123 \n 5     1     5 0.177 \n 6     1     6 0.239 \n 7     1     7 0.308 \n 8     1     8 0.384 \n 9     1     9 0.465 \n10     1    10 0.550 \n# ℹ 9,990 more rows\n\n\nAfter that, we now have a grid of angles that represents a functional flow field. We can visualize this field in the same way as we did before:\n\nvisualize_grid(grid, n)\n\n\n\n\n\n\n\n\nThat looks much more natural compared to the previous grids! It also feels much more fluid. Like winds flowing and doing smooth curves around this grid.\nYou could also use the Simplex Noise algorithm to generate the random values, instead of the classic Perlin Noise. As we described at Section 3.4, the Simplex Noise algorithmn produces “stronger” results, with random values that vary more rapidly across the grid. As a result, a flow field created from Simplex Noise is less smooth compared to a flow field created from Perlin Noise. You can see that in the example below:\n\nset.seed(50)\nangles &lt;- noise_simplex(c(n, n)) * 2 * pi\ngrid &lt;- build_grid_df(angles, n)\nvisualize_grid(grid, n)\n\n\n\n\n\n\n\n\n\n\n\n\nHobbs, Tyler. 2024. “Flow Fields.” https://tylerxhobbs.com/essays/2020/flow-fields.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introducing Flow Fields</span>"
    ]
  },
  {
    "objectID": "Chapters/_references.html",
    "href": "Chapters/_references.html",
    "title": "References",
    "section": "",
    "text": "Hobbs, Tyler. 2024. “Flow Fields.” https://tylerxhobbs.com/essays/2020/flow-fields.\n\n\nWickham, Hadley. 2016. Ggplot2: Elegant Graphics for Data\nAnalysis. Springer-Verlag New York. https://ggplot2.tidyverse.org.\n\n\nWickham, Hadley, Winston Chang, Lionel Henry, Thomas Lin Pedersen,\nKohske Takahashi, Claus Wilke, Kara Woo, Hiroaki Yutani, and Dewey\nDunnington. 2024. “Ggplot2 3.4.4 Official Documentation.”\nhttps://ggplot2.tidyverse.org/index.html.\n\n\nWikipedia, The Free Encyclopedia. 2024. “Perlin Noise.” https://en.wikipedia.org/wiki/Perlin_noise.",
    "crumbs": [
      "References"
    ]
  }
]